---
title: Vibecoding with Blockstudio
description: How to build WordPress blocks, pages, and full sites using AI coding agents. Practical patterns for getting the most out of Blockstudio's file-based architecture.
---

Andrej Karpathy coined the term "vibe coding" in February 2025 to describe a workflow where you describe what you want to an AI and it writes the code. One year later, the practice has matured into what he now calls "agentic engineering": developers orchestrating AI agents rather than writing code line by line.

Blockstudio was built for this. Its file-based architecture, zero build tooling, and predictable project structure make it one of the best environments for AI-assisted WordPress development.

This guide covers practical patterns for using AI coding agents with Blockstudio, from project setup to full site generation.

## Why Blockstudio works well with AI agents

### Files, not databases

AI coding agents read and write files. That is their primary interface. Blockstudio keeps everything in the filesystem: a `block.json` and a template file per block, a `page.json` per page, a `pattern.json` per pattern. No database entries to manage, no admin UI to click through, no build step to run.

This matters because filesystems and shell commands represent one of the largest sources of pretraining data for LLMs. Every model has seen millions of examples of reading, writing, and organizing files. When your WordPress development workflow matches that interface, agents can work with minimal instruction.

### Predictable structure

Every Blockstudio block follows the same pattern:

```
my-block/
├── block.json    # Configuration + fields
├── index.php     # Template
└── style.css     # Styles (optional)
```

This consistency means an agent that has built one block can build a hundred. There are no surprises, no special cases, no hidden configuration. The same pattern applies to pages (`page.json` + template), patterns (`pattern.json` + template), and extensions (`extend.json`).

### No build step

There is nothing to compile, bundle, or transpile. An agent creates a file, and it works immediately. SCSS is compiled server-side. ES modules are resolved at runtime. Tailwind CSS is compiled on every frontend request. The feedback loop between "agent writes code" and "code runs in the browser" is as short as it gets.

## Why Tailwind CSS is the right choice

Blockstudio supports both regular CSS and Tailwind CSS, but Tailwind has a significant advantage when working with AI agents.

### LLMs know Tailwind extremely well

Tailwind CSS is used across tens of thousands of open-source repositories. It powers the interfaces of Claude.ai, Vercel, Shopify, Cursor, and OpenAI's own products. This prevalence in training data means LLMs generate Tailwind classes with high accuracy and rarely hallucinate non-existent utilities.

The class vocabulary is finite and well-defined. An agent cannot invent a CSS property that does not exist, which dramatically reduces styling errors compared to freeform CSS where the agent might generate invalid selectors or misunderstand cascade behavior.

### Styles live in the markup

With Tailwind, all styling information is co-located in the HTML template. An agent sees the complete visual description of an element in one place. There is no need to cross-reference separate `.css` files, understand cascade order, or track specificity conflicts.

This is particularly powerful for Blockstudio blocks where the template is already a single file. The agent can generate a complete, styled component in one pass:

```php title="index.php"
<div useBlockProps class="bg-white rounded-2xl shadow-lg p-8">
  <h2 class="text-2xl font-bold text-gray-900">
    <?php echo $a['title']; ?>
  </h2>
  <p class="mt-4 text-gray-600 leading-relaxed">
    <?php echo $a['description']; ?>
  </p>
</div>
```

### Parallel agents without conflicts

Because Tailwind styles are scoped to each template, multiple agents (or developers) can work on different blocks simultaneously without CSS merge conflicts. There is no shared stylesheet where changes to one component accidentally break another. Each block is self-contained.

This also works well with regular CSS when using Blockstudio's scoped styles (`style.scoped.css`), but Tailwind eliminates the CSS file entirely, which means one fewer file for the agent to manage per block.

### Regular CSS still works

Tailwind is not required. Blockstudio's asset pipeline handles `.css` and `.scss` files automatically, including scoped styles that are namespaced to the block. If your project uses a different CSS methodology, agents can work with that too. The advantage of Tailwind is simply that LLMs are better at it due to training data coverage and the co-location of styles with markup.

## AI coding agents

The following CLI tools can all work with Blockstudio projects out of the box. They read and write files, run shell commands, and understand project structure from context files.

### Terminal agents (CLI)

| Tool | Provider | Notes |
|------|----------|-------|
| [Claude Code](https://claude.ai) | Anthropic | Terminal-first agent. Reads `CLAUDE.md` for project context. |
| [Codex CLI](https://github.com/openai/codex) | OpenAI | Open-source CLI built in Rust. Also available as a desktop app. |
| [Gemini CLI](https://github.com/google-gemini/gemini-cli) | Google | Open-source with 1M token context window. Reads `GEMINI.md`. |
| [GitHub Copilot CLI](https://github.com/features/copilot/cli) | GitHub | Specialized parallel agents for explore, task, plan, and review. |
| [Aider](https://aider.chat) | Open source | Supports 100+ LLM providers including local models. |
| [OpenCode](https://opencode.ai) | Open source | Terminal TUI with LSP integration. Supports 75+ providers. |
| [Amazon Q Developer CLI](https://aws.amazon.com/q/developer/) | AWS | Free tier available. Strong for AWS-integrated projects. |

### IDE agents

| Tool | Provider | Notes |
|------|----------|-------|
| [Cursor](https://cursor.com) | Cursor | VS Code fork with built-in AI. Also has a CLI (beta). |
| [Windsurf](https://windsurf.com) | Cognition AI | VS Code fork with Cascade agentic assistant. |
| [Cline](https://cline.bot) | Open source | VS Code extension with step-by-step approval. Also has a CLI. |
| [Kilo Code](https://kilo.ai) | Open source | Orchestrator mode with coordinated sub-agents. |
| [Continue](https://continue.dev) | Open source | VS Code/JetBrains extension with async CI/CD agents. |
| [Augment Code](https://augmentcode.com) | Augment | Enterprise-focused with deep codebase indexing. |

All of these tools can create and edit files in a Blockstudio project directory. The terminal agents are particularly well-suited because Blockstudio development requires no IDE-specific features: it is purely file-based.

## Setting up your project for AI agents

### Context files

Most AI coding agents read a project-level context file that tells them about the codebase. The convention varies by tool:

| File | Tool |
|------|------|
| `CLAUDE.md` | Claude Code |
| `AGENTS.md` | Codex CLI, Gemini CLI, Copilot CLI, and others |
| `.cursor/rules/*.mdc` | Cursor |
| `.github/copilot-instructions.md` | GitHub Copilot |

A good context file for a Blockstudio project should include:

1. **Project structure**: where blocks, pages, and patterns live
2. **Commands**: how to run tests, start the dev server, check coding standards
3. **Conventions**: naming patterns, file organization, coding style
4. **Boundaries**: what the agent should not touch

Here is a minimal example:

```markdown title="CLAUDE.md"
# My WordPress Site

Built with Blockstudio 7. File-based blocks with Tailwind CSS.

## Structure

- `blockstudio/` - Custom blocks (block.json + index.php + style.css)
- `pages/` - File-based pages (page.json + index.php)
- `patterns/` - Block patterns (pattern.json + index.php)
- `blockstudio.json` - Plugin settings

## Block pattern

Every block has a `block.json` with field definitions and an `index.php`
template. Use Tailwind utility classes for styling. Use `$a['fieldId']`
to access field values in templates.

## Commands

- `wp server` - Start local development server
```

### The LLM context file

Blockstudio can generate a comprehensive context file at `your-site.com/blockstudio-llm.txt` that contains the full framework documentation and JSON schemas (~48k tokens). Enable it in your `blockstudio.json`:

```json title="blockstudio.json"
{
  "ai": {
    "enableContextGeneration": true
  }
}
```

Point your AI tool to this URL so it understands the full Blockstudio API. See the [AI integration docs](/docs/dev/ai) for tool-specific instructions.

## Practical patterns

### Building a single block

The simplest workflow: describe what you want and let the agent create it.

**Prompt:**

> Create a testimonial block with fields for quote (textarea), author name
> (text), author role (text), and author photo (files). Use Tailwind for
> styling. The quote should be in a large italic font with a decorative
> quotation mark.

The agent will create:

```
blockstudio/testimonial/
├── block.json
└── index.php
```

### Building a full page

Blockstudio's file-based pages let an agent scaffold an entire WordPress page as a template:

**Prompt:**

> Create an "About" page with a hero section, team grid, and contact form
> placeholder. Use existing blocks where possible, write new ones where
> needed. Pin it to post ID 2.

The agent creates the page template and any blocks it references, all as files.

### Building a full site

This is where Blockstudio's architecture really shines. A single prompt can generate an entire site because every artifact is a file:

**Prompt:**

> Build a portfolio website with these pages: Home, Work, About, Contact.
> Create custom blocks for: hero section, project grid, project card,
> team member, contact info, and footer. Use a dark theme with Tailwind.
> Configure Tailwind in blockstudio.json with a custom color palette.

The agent creates the block directories, page templates, a `blockstudio.json` with Tailwind config, and optionally patterns for reusable sections. Everything is committed to git as a single changeset.

### Parallel agent workflows

Some tools (Codex desktop app, GitHub Copilot CLI, Kilo Code) support running multiple agents in parallel. Blockstudio's file-per-block architecture makes this safe:

- **Agent 1**: builds the hero block and home page
- **Agent 2**: builds the project card block and work page
- **Agent 3**: builds the contact form block and contact page

Because each block is its own directory and Tailwind styles are co-located in templates, these agents will not conflict with each other. The only shared file is `blockstudio.json`, which typically only needs to be set up once at the start.

## Tips for better results

1. **Reference the LLM context file.** Agents produce significantly better Blockstudio code when they have the full framework documentation. Always point them to `blockstudio-llm.txt`.

2. **Be specific about field types.** Instead of "add an image field," say "add a files field with `allowedTypes: ['image']` and `returnFormat: 'object'`." The more precise your field definitions, the fewer iterations needed.

3. **Start with one block, then scale.** Let the agent build one block correctly, review its patterns, and then ask it to build the rest following the same conventions. This establishes a reference that improves subsequent output.

4. **Review the output.** Vibe coding does not mean blindly accepting code. Check that field types match your intent, templates render correctly, and Tailwind classes produce the right visual result. AI-generated code should be reviewed before shipping.

5. **Use `block.json` schemas.** Blockstudio provides a JSON Schema at `https://app.blockstudio.dev/schema/block`. Adding `"$schema"` to your block.json gives agents validation feedback and prevents malformed configurations.

6. **Keep blocks small and focused.** One block per visual component. This makes each block easier for the agent to reason about and keeps templates short enough to fit in a single context window pass.
