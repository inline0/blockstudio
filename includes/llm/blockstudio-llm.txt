# Blockstudio
Context about the Blockstudio WordPress block framework for LLM coding assistants.

## Documentation

## Introduction

Blockstudio enables you to create custom WordPress blocks with nothing but PHP
using the WordPress
block.json
format. It greatly simplifies the developer experience in regard to block
registration, lazy loading assets, and custom fields.

## Philosophy

### Core focused

There is no secret sauce. Blockstudio is built on top of core WordPress features
and Gutenberg components. It is designed to be a lightweight abstraction layer
that helps you get started with custom blocks quickly.

### Server side first

When creating dynamic blocks using nothing but WordPress, there is duplication
of logic between PHP and JS code. There are
discussions about
solving this issue, including hydrating blocks on the client side (not good for
SEO) or introducing a JSX parser for PHP (complex).

Blockstudio takes a different approach. You use PHP to write your block
templates and sprinkle in interactivity like `<RichText />` or `<InnerBlocks />`
using JSX-like tags. Inside the editor, those tags will be replaced with their
React counterparts. On the frontend, the tags will be replaced with HTML
content.

This way, you get the best of both worlds: a server-side rendered block with
great interactivity in the editor.

### File system based

While WordPress supports a file-based approach using the
WPDefinedPath
string type, it is also possible to link assets or templates from other
destinations. Blockstudio doubles down on the file-system as the primary (and
only) way of registering blocks. This decision was not made to restrict, but to
set a block structure in place that can't be argued with. For example, if a
`style.css` or `script.js` file is found in the same folder as a block.json,
then you can be sure that it belongs to this exact block only.

### No setup

Blockstudio just works. It is designed to remove friction when composing custom
blocks and doesn't come in your way while doing so. Want to use Twig for your
template? Simply rename the file extension. Need to include some CSS? Create a
`style.css` file. Blockstudio will automatically enqueue it whenever the block
is being used on your page, even when it is used outside the post_content with
the rendering function.

Do you have feature requests or questions? Message
us.

### Getting Started

This guide will help you set up Blockstudio and create your first custom block.

## Installation

### Via Composer (Recommended)

```bash
composer require blockstudio/blockstudio
```

### Manual Installation

1. Download the latest release from GitHub
2. Upload to your WordPress plugins directory
3. Activate the plugin

## Creating Your First Block

### 1. Create a Block Directory

Create a new directory in your theme:

```
my-theme/
  blockstudio/
    my-first-block/
      block.json
      index.php
```

### 2. Define the Block Schema

Create `block.json` with your block configuration:

```json
{
  "$schema": "https://app.blockstudio.dev/schema",
  "name": "my-theme/my-first-block",
  "title": "My First Block",
  "category": "common",
  "icon": "star-filled",
  "blockstudio": {
    "attributes": [
      {
        "id": "heading",
        "type": "text",
        "label": "Heading",
        "default": "Hello World"
      },
      {
        "id": "content",
        "type": "textarea",
        "label": "Content"
      }
    ]
  }
}
```

### 3. Create the Template

Create `index.php` for rendering:

```php
<div class="my-first-block">
  <h2><?php echo $a['heading']; ?></h2>
  <p><?php echo $a['content']; ?></p>
</div>
```

## Using Twig Templates

Blockstudio supports Twig templates out of the box. Simply use `index.twig` instead:

```twig
<div class="my-first-block">
  <h2>{{ a.heading }}</h2>
  <p>{{ a.content }}</p>
</div>
```

## Adding Styles

Create a `style.css` file in the same folder:

```css
.my-first-block {
  padding: 2rem;
  background: #f5f5f5;
}
```

Blockstudio will automatically enqueue this stylesheet when the block is used.

## Next Steps

Your block is now ready to use in the WordPress editor. Continue exploring the documentation to learn about:

- Field Types - All available field types
- Components - InnerBlocks, RichText, and more
- Tailwind Integration - Using Tailwind CSS
- Hooks - Extending functionality with filters and actions

### Settings

Blockstudio includes a powerful settings API, that allows setting options via a `blockstudio.json` file inside your theme folder and/or filters. Additionally, allowed users are able to change the settings visually inside the admin area.

## Via JSON

If a `blockstudio.json` file is present inside your theme folder, it will be used to set the default options for the current site. A JSON schema is available to validate the file and help with autocompletion when used in an IDE.

The following properties are available:

```json
{
  "$schema": "https://app.blockstudio.dev/schema/blockstudio",
  "users": {
    "ids": [],
    "roles": []
  },
  "assets": {
    "enqueue": true,
    "minify": {
      "css": false,
      "js": false
    },
    "process": {
      "scss": false
    }
  },
  "editor": {
    "formatOnSave": false,
    "assets": [],
    "markup": false
  },
  "library": false
}
```

## Via Filters

Alternatively you can use the `blockstudio/settings/${setting}` filter to set options via PHP for more flexibility.

```php
add_filter('blockstudio/settings/assets/enqueue', '__return_false');
add_filter('blockstudio/settings/editor/formatOnSave', '__return_true');
add_filter('blockstudio/settings/library', '__return_true');
```

Options set via the `blockstudio/settings/${setting}` filter will override the ones set via the `blockstudio.json` file. Both methods can be used together.

## Via Admin

Allowed users from the `blockstudio/settings/users/ids` and `blockstudio/settings/users/roles` filters are able to change the settings visually inside the admin area. If the `Save as JSON` checkbox is checked, the settings will be saved to the JSON file, otherwise they will be saved to the database into the `options` table.

Settings set via filters will be grayed out and disabled inside the admin area.

## Available Settings

### users

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `ids` | array | `[]` | User IDs with editor access |
| `roles` | array | `[]` | User roles with editor access |

### assets

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `enqueue` | boolean | `true` | Auto-enqueue block assets |
| `minify.css` | boolean | `false` | Minify CSS output |
| `minify.js` | boolean | `false` | Minify JS output |
| `process.scss` | boolean | `false` | Process SCSS files |

### editor

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `formatOnSave` | boolean | `false` | Format block.json on save |
| `assets` | array | `[]` | Additional assets to load in editor |
| `markup` | boolean | `false` | Enable markup editing |

### library

| Type | Default | Description |
|------|---------|-------------|
| boolean | `false` | Enable the block library |

### tailwind

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `enabled` | boolean | `false` | Enable Tailwind CSS compilation |
| `config` | string | `""` | Tailwind v4 CSS-first configuration |

### blockEditor

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `disableLoading` | boolean | `false` | Disable block loading in editor |

### Registration

Composing your own blocks with Blockstudio is extremely easy. The plugin will
look for a `blockstudio` folder within your currently activated theme. Inside
it, all subfolders that contain a `block.json` file with a `blockstudio` key
will be registered.

## block.json

```json
{
  "name": "blockstudio/native",
  "title": "Native Block",
  "category": "text",
  "icon": "star-filled",
  "description": "Native Blockstudio block.",
  "blockstudio": true
}
```

## Template

So far, the custom block is not going to be registered since it is missing a
template. To fix that just create an `index.php` in the same folder as your
block.json file and its contents will automatically be rendered when your block
is used.

```php
<h1>My first native block.</h1>
```

## Conditional logic

Blocks can be registered conditionally using the `conditions` key. It supports
all the global variables which are also available for attributes.

See all conditions

The following example will only register the block if the current post type is a
page:

```json
{
  "blockstudio": {
    "conditions": [
      [
        {
          "type": "postType",
          "operator": "==",
          "value": "page"
        }
      ]
    ]
  }
}
```

## Custom icon

Custom SVGs icons for blocks can be registered like so:

```json
{
  "blockstudio": {
    "icon": "<svg></svg>"
  }
}
```

WordPress doesn't allow for custom SVG icons inside its own block.json `icon`
key, only
Dashicons
IDs are allowed here.

### HTML

Blockstudio is using a React element parser to render the icon element, so it is
possible to use HTML inside the icon string.

```json
{
  "blockstudio": {
    "icon": "<div>:-)</div>"
  }
}
```

## Custom paths

By default, Blockstudio will recursively look through the `blockstudio` folder
inside your current theme or child theme for blocks. You can change that
behaviour in two ways.

### Filter

```php
// Custom path within your theme.
add_filter('blockstudio/path', function () {
    return get_template_directory() . '/blocks';
});

// Custom path within a plugin.
add_filter('blockstudio/path', function () {
    return plugins_url() . '/my-custom-plugin/blocks';
});
```

### Instances

If the above options are not enough, it is possible to initiate the
`Blockstudio\Build` class on various folders of your choice:

```php
add_action('init', function () {
  Blockstudio\Build::init([
    'dir' => get_template_directory() . '/client-blocks'
  ]);
});
```

## Filter metadata

Metadata can be filtered before the block is being registered using the
`blockstudio/block/meta` filter:

```php
add_filter('blockstudio/block/meta', function ($meta, $block) {
    if (str_starts_with($block['name'], 'marketing')) {
        $meta['icon'] = 'megaphone';
    }
    return $meta;
}, 10, 2);
```

The example above is being used internally to give all Blockstudio library
elements the same icon.

#### Twig

Twig is a flexible, fast, and secure template engine for PHP. It allows developers to write concise and readable code in templates, enhancing productivity and maintainability. Twig supports a variety of features designed to make templating both powerful and straightforward, making it ideal for projects that require robust, reusable templates.

## Setup

To use Twig templates with Blockstudio, you need to install the `timber/timber` package (which includes Twig) using Composer. Blockstudio will automatically detect if Timber is installed and enable Twig templating for your blocks.

```bash
composer require timber/timber
```

Once Timber is installed, Blockstudio will automatically handle the rendering of `index.twig` files found within your block folders.

## Template Variables

All Twig files will have access to the Timber context, which includes common WordPress data and functions, as well as Blockstudio-specific variables:

| Variable | Description |
|----------|-------------|
| `a` | An alias for `attributes` |
| `attributes` | The block's attributes |
| `b` | An alias for `block` |
| `block` | Data related to the block itself (includes `postId`, `postType`, `context`, etc.) |
| `c` | An alias for `context` |
| `context` | The block's context (e.g., `postId`, `postType` when in a loop) |
| `isEditor` | Boolean, true if the block is rendering in the editor |
| `isPreview` | Boolean, true if the block is rendering in the inserter preview |

## Usage

To use Twig for your block's template, simply create an `index.twig` file in your block's directory. Blockstudio will then automatically use this file for rendering the block.

```twig
<div class="my-block">
  {% if a.title %}
    <h2>{{ a.title }}</h2>
  {% endif %}

  {% if a.content %}
    <p>{{ a.content }}</p>
  {% endif %}
</div>
```

#### Blade

Blade is a templating engine used primarily with the Laravel framework. It enables developers to create expressive, clean templates using a syntax that extends PHP in a simple and intuitive way. Blade templates facilitate common tasks like data display and layout management, helping streamline the development of dynamic web pages.

## Setup

To use Blade templates with Blockstudio, you first need to install the `jenssegers/blade` package using Composer.

```bash
composer require jenssegers/blade
```

Next, you need to add a filter to your theme's `functions.php` file to tell Blockstudio how to render Blade templates. Blockstudio automatically collects all Blade templates and maps their paths, allowing you to use Blade's dot syntax for includes and layouts.

```php
add_filter(
    "blockstudio/blocks/render",
    function ($value, $block) {
        $blockPath = $block->path;
        if (str_ends_with($blockPath, ".blade.php")) {
            // Ensure the Blade class exists before trying to use it.
            if (!class_exists('Jenssegers\Blade\Blade')) {
                // Optionally, you could log an error or return a message.
                return 'Error: Blade class not found. Please run "composer require jenssegers/blade".';
            }
            $data = $block->blockstudio["data"];
            $bladeData = $data["blade"];
            $blade = new \Jenssegers\Blade\Blade($bladeData["path"], sys_get_temp_dir());

            return $blade->render($bladeData["templates"][$block->name], [
                "a" => $data["attributes"],
                "attributes" => $data["attributes"],
                "b" => $data["block"],
                "block" => $data["block"],
                "c" => $data["context"],
                "context" => $data["context"],
            ]);
        }

        return $value;
    },
    10,
    2
);
```

## Template Variables

Your Blade templates will have access to the following variables:

| Variable | Description |
|----------|-------------|
| `$a` | An alias for `$attributes` |
| `$attributes` | The block's attributes |
| `$b` | An alias for `$block` |
| `$block` | Data related to the block itself |
| `$c` | An alias for `$context` |
| `$context` | The block's context (e.g., post ID, post type when in a loop) |

## Usage

To use Blade for your block's template, create an `index.blade.php` file in your block's directory. Blockstudio will then automatically use this file for rendering the block.

```php
<div class="my-block">
  @if($a['title'])
    <h2>{{ $a['title'] }}</h2>
  @endif

  @if($a['content'])
    <p>{{ $a['content'] }}</p>
  @endif
</div>
```

### Schema

To improve development with autocomplete and validation in your IDE, Blockstudio introduces its own schema:

View Blockstudio schema

The Blockstudio schema is an (always up-to-date) copy of the WordPress core block.json schema with an additional `blockstudio` property that houses all plugin features like field schemas without interfering with potential future core properties.

## Add to JSON

Simply add a `$schema` key with a value of https://app.blockstudio.dev/schema to your block.json and your IDE should start to give you hints about Blockstudio specific properties.

```json
{
  "$schema": "https://app.blockstudio.dev/schema",
  "name": "blockstudio/native",
  "title": "Native Block",
  "category": "text",
  "icon": "star-filled",
  "description": "Native Blockstudio block.",
  "blockstudio": true
}
```

## IDE Support

### VS Code

VS Code automatically picks up the schema from the `$schema` property.

For workspace-wide settings, add to `.vscode/settings.json`:

```json
{
  "json.schemas": [
    {
      "fileMatch": ["/block.json"],
      "url": "https://app.blockstudio.dev/schema"
    }
  ]
}
```

### JetBrains IDEs

PhpStorm and other JetBrains IDEs support JSON Schema via the `$schema` property automatically.

## Available Schemas

| Schema | URL |
|--------|-----|
| Block Schema | `https://app.blockstudio.dev/schema` |
| Extension Schema | `https://app.blockstudio.dev/schema/extend` |

## Benefits

- Autocomplete: Get suggestions for all available properties
- Validation: Catch errors before runtime
- Documentation: Hover over properties for inline documentation
- Type Safety**: Ensure correct value types

### Assets

Blockstudio provides a zero-config asset pipeline for your blocks. Drop CSS, SCSS, or JavaScript files next to your block and they get compiled, minified, and enqueued automatically.

- Registering Assets:File naming conventions and enqueue behavior
- Processing:SCSS compilation, ES module imports, and minification
- Code Field:Inline code editing via the code field type

#### Assets

Blockstudio provides a zero-config asset pipeline for your blocks. Drop CSS, SCSS, or JavaScript files next to your block and they get compiled, minified, and enqueued automatically.

- Registering Assets:File naming conventions and enqueue behavior
- Processing:SCSS compilation, ES module imports, and minification
- Code Field:Inline code editing via the code field type

#### Registering Assets

Blockstudio will automatically enqueue all files ending with `.css`, `.scss` and `.js` when your block is being used on a page. It is possible to define how assets are being enqueued by using one of the following file names. The `` is a wildcard that can be replaced with any string of your choice.

| Pattern | Behavior |
|---------|----------|
| `.(s)css` | Enqueues as a `<link>` tag in the editor and on the frontend |
| `.inline.(s)css` | Enqueues contents in an inline `<style>` tag in the editor and on the frontend |
| `.editor.(s)css` | Enqueues as a `<link>` tag in the editor only |
| `.scoped.(s)css` | Enqueues scoped contents in an inline `<style>` tag in the editor and on the frontend |
| `.js` | Enqueues as a `<script>` tag in the editor and on the frontend |
| `.inline.js` | Enqueues contents in an inline `<script>` tag in the editor and on the frontend |
| `.editor.js` | Enqueues as a `<script>` tag in the editor only |
| `.view.js` | Enqueues as a `<script>` tag on the frontend only |

The dash notation (`-inline.css`, `*-editor.css`, etc.) is still supported for backward compatibility but is deprecated. Use dot notation for new blocks.

## Inline

Inline styles and scripts have the big advantage that they are directly rendered as style or script tags inside the page. This can enhance loading times, since it saves extra requests that would have to be made otherwise.

- `.js` files are inlined to the end of the body
- `.(s)css` files are inlined to the end of the head
- Each file is only being inlined once

## Scoped

Scoped styles are also inlined, but are prefixed with an ID that is unique to each block. Use the `bs_get_scoped_class` function to add the class to your template.

```php
<div class="<?php echo bs_get_scoped_class($b["name"]) ?>">
  <h1>Scope me!</h1>
  <p>Scope me too!</p>
</div>
```

```css
h1 {
  color: red;
}
```

The above will result in the following scoped style:

```html
<style>
  .bs-62df71e6cc9a h1 {
      color: red;
  }
  .bs-62df71e6cc9a p {
      color: blue;
  }
</style>

<div class="bs-62df71e6cc9a">
  <h1>Scope me!</h1>
  <p>Scope me too!</p>
</div>
```

## Global

Besides block specific assets, it is also possible to enqueue global assets, which will be available on all pages, regardless if a block is present. Enqueuing a global asset is done by adding the `global-` prefix to the file name. Any of the suffixes (e.g. `-inline`) can be used in combination.

Possible combinations are:

- `global-styles.(s)css`
- `global-styles.inline.(s)css`
- `global-styles.editor.(s)css`
- `global-styles.scoped.(s)css`
- `global-scripts.js`
- `global-scripts.inline.js`
- `global-scripts.editor.js`
- `global-scripts.view.js`

## Admin

Admin assets are enqueued only in the WordPress admin area. The `admin-` prefix is used to define admin assets.

- `admin-styles.(s)css`
- `admin-scripts.js`

## Block Editor

Block editor assets are enqueued only in the block editor. The `block-editor-` prefix is used to define block editor assets.

- `block-editor-styles.(s)css`
- `block-editor-scripts.js`

## Disable Enqueuing

Automatic asset enqueuing can be disabled using the `assets/enqueue` setting. This is useful if you want to handle all asset enqueuing by yourself.

```php
add_filter('blockstudio/settings', function($settings) {
  $settings['assets']['enqueue'] = false;
  return $settings;
});
```

### Per Block

When a block templates returns nothing, Blockstudio will not enqueue any assets for that particular block. This method comes in handy to disable enqueueing when a certain condition is met.

```php
<?php
  if ( !$a['slides'] ) {
    // or return '';
    return false;
  }
?>

<div>my slider</div>
```

```twig
{% if not a.slides %}
  <div>my slider</div>
{% endif %}
```

#### Processing Assets

## Minification

Blockstudio is able to automatically minify all CSS and JS files in a block.

Compiled files will be saved to the `_dist` folder of the block and enqueued when a block is used. When the source file is updated, Blockstudio checks if a compiled file with that timestamp exists, if not, it will be created.

The minify library is used for this purpose.

Minification can be enabled using the `assets/minify` setting:

```php
add_filter('blockstudio/settings/assets/minify/css', function() {
  return true;
});

add_filter('blockstudio/settings/assets/minify/js', function() {
  return true;
});
```

## SCSS

If you prefer writing your styles in SCSS, you can enable SCSS processing:

```php
add_filter('blockstudio/settings/assets/process/scss', function() {
  return true;
});
```

This will turn on SCSS processing for `.css` files.

Alternatively, you can use the `.scss` extension and styles will automatically get processed even when the above setting is not `true`.

### Import Paths

When using SCSS, it is possible to import other SCSS files. Imports are relative to the file they are imported from.

```css
@import "modules.scss";
```

Additionally, custom import paths can be defined using the `blockstudio/assets/process/scss/import_paths` filter, so files can be imported from other directories without specifying any folder structure.

Please note that the `.scss` extension needs to be present for imports to work properly.

```php
add_filter('blockstudio/assets/process/scss/import_paths', function($paths) {
  $paths[] = get_template_directory() . '/scss';
  return $paths;
});
```

Block assets will be recompiled when any of the imported files change.

## ES Modules

All scripts (inline and default) in Blockstudio load with `type="module"` applied to them by default. This means that it is possible to make use of the import syntax for your blocks' scripts without any additional setup.

For a more in-depth look into ES modules, visit the MDN web docs.

Let's imagine the following code inside a script.js:

```javascript
import { h, render } from "https://esm.sh/preact@10.15.1";
import htm from "https://esm.sh/htm@3.1.1";
import confetti from "https://esm.sh/canvas-confetti@1.6.0";

const html = htm.bind(h);

function App(props) {
  confetti();
  return html`<h1>Hello ${props.name}!</h1>`;
}

render(
  html`<${App} name="Hello from Preact!" />`,
  document.querySelector("#element")
);
```

The example above would create a component using Preact, importing all necessary components and functions from an ESM compatible CDN, in this case esm.sh. While there is nothing wrong with this approach, it has the disadvantage of needing to request the necessary assets from an external site, risking broken scripts if the CDN is down.

Blockstudio includes a handy way to download ES Modules to the block, eliminating the need for external ESM CDNs during production.

### Setup

To download a module to your block directory, use the `npm:` prefix followed by the package name and version:

```javascript
import { h, render } from "npm:preact@10.15.1";
import htm from "npm:htm@3.1.1";
import confetti from "npm:canvas-confetti@1.6.0";
```

This syntax aligns with Deno's npm specifier convention.

The legacy `blockstudio/` prefix (e.g., `blockstudio/preact@10.15.1`) is still supported for backward compatibility, but we recommend using the `npm:` prefix for new projects. See the migration guide for details.

Blockstudio will automatically check changed .js files for imports and download them to the local block directory. The downloaded files will be placed in a `modules` folder in the block directory.

The script file will be rewritten on save to accustom for the locally hosted module:

```javascript
import { h, render } from "./modules/preact/10.15.1.js";
import htm from "./modules/htm/10.15.1.js";
import confetti from "./modules/canvas-confetti/1.6.0.js";
```

When inside the editor, the CDN url will still be used (Blockstudio is using esm.sh) when previewing and working on the block.

### Caveats

#### Version

Normally, modules can be used from CDNs without the version number. In this case, the newest version will always be used. Since Blockstudio is not saving any information into the database, a version number is required when using modules.

#### Same Modules

Modules are scoped to their blocks. Even if you use the same module with the same version number across multiple blocks, Blockstudio will still download the requested module to the block. This is mainly because blocks should be self-contained units that can easily be shared across other installations or sites.

On top of that, the same module will be requested twice if both blocks are present on a page. This problem can be solved by using the `script-inline.js` instead of the `script.js` file. Blockstudio will rewrite each of the imports to point to the location of the first occurrence of the module if the name and version number are the same.

## CSS Loader

It is also possible to import CSS files using the same syntax as above.

```javascript
import "npm:swiper@11.0.0/swiper.min.css";
```

The CSS file will be downloaded to the `modules` folder and automatically enqueued when the block is used. As long as the version is the same, only a single version of the CSS file will be enqueued, even if it exists in multiple blocks.

#### Code Field Assets

Beside static styles and scripts as files, Blockstudio also supports dynamic asset blocks via the code field. Depending on your use case, these can be scoped to the block.

## Basic Usage

At the most basic level, you can manually render the code field content in your template.

```php
<div useBlockProps>
  <h1>My block</h1>
</div>
<style><?php echo $attributes['css']; ?></style>
```

```twig
<div useBlockProps>
  <h1>My block</h1>
</div>
<style>{{ attributes.css }}</style>
```

## Scoped Selector

To avoid conflicts with other blocks, you can use the `%selector%` variable inside the code field alongside useBlockProps in your rendering template.

### Example

Let's imagine that we want to target the `h1` tag from the example above in our code field.

```css
%selector% h1 {
  color: red;
}
```

Now, Blockstudio will do three things:

- Create a unique id for that block instance
- Replace `%selector%` with the unique id
- Add the same selector to the element marked with `useBlockProps`

The final output will be something like this:

```html
<div data-assets="c9abe0d95c2b">
  <h1>My block</h1>
</div>
<style>
  [data-assets="c9abe0d95c2b"] h1 {
    color: red;
  }
</style>
```

## Automatic Rendering

Always having to render the style tag manually can be cumbersome. To make this process easier, you can use the `asset` attribute inside the code field.

```json
{
  "blockstudio": {
    "attributes": [
      {
        "type": "code",
        "id": "code",
        "label": "Custom CSS",
        "language": "css",
        "asset": true
      }
    ]
  }
}
```

This will automatically create `style` tags for code blocks marked as `css` and move them to the head of the document. For fields marked with `javascript` as the language, `script` tags will be created instead and placed at the bottom of the body.

## In Extensions

When using code fields inside of extensions, the `asset` attribute is not necessary. Blockstudio will automatically render the code field content as an asset if the language is `css` or `javascript`.

### Example

```json
{
  "$schema": "https://app.blockstudio.dev/schema/extend",
  "name": "core/",
  "blockstudio": {
    "extend": true,
    "attributes": [
      {
        "id": "customCss",
        "type": "code",
        "label": "Custom css",
        "language": "css"
      }
    ]
  }
}
```

No additional configuration is needed. The above will show a code field for every `core/` block in the sidebar and automatically render the content as an asset to the page.

#### Registering Attributes

Attributes are defined within the `blockstudio.attributes` array in your block.json file.

## Basic Example

```json
{
  "name": "my-theme/my-block",
  "title": "My Block",
  "blockstudio": {
    "attributes": [
      {
        "id": "title",
        "type": "text",
        "label": "Title"
      },
      {
        "id": "content",
        "type": "textarea",
        "label": "Content"
      }
    ]
  }
}
```

## Attribute Properties

All attributes share the following properties:

| Property | Type | Description |
|----------|------|-------------|
| `id` | string | Unique identifier for the attribute |
| `type` | string | The field type (text, textarea, select, etc.) |
| `label` | string | Label displayed in the editor |
| `default` | mixed | Default value for the attribute |
| `help` | string | Help text displayed below the field |
| `position` | string | Where the field appears: `inspector` (default) or `toolbar` |
| `conditions` | array | Conditional logic for showing/hiding the field |

## Position

By default, all fields are displayed in the block inspector (sidebar). You can change this using the `position` property:

```json
{
  "blockstudio": {
    "attributes": [
      {
        "id": "alignment",
        "type": "select",
        "label": "Alignment",
        "position": "toolbar",
        "options": [
          { "value": "left", "label": "Left" },
          { "value": "center", "label": "Center" },
          { "value": "right", "label": "Right" }
        ]
      }
    ]
  }
}
```

## Default Values

Set default values using the `default` property:

```json
{
  "blockstudio": {
    "attributes": [
      {
        "id": "title",
        "type": "text",
        "label": "Title",
        "default": "Hello World"
      },
      {
        "id": "showBorder",
        "type": "toggle",
        "label": "Show Border",
        "default": true
      }
    ]
  }
}
```

## Help Text

Add help text to guide users:

```json
{
  "blockstudio": {
    "attributes": [
      {
        "id": "apiKey",
        "type": "text",
        "label": "API Key",
        "help": "Enter your API key from the settings page"
      }
    ]
  }
}
```

## Accessing Attributes

In your template, attributes are available via the `$a` shorthand (or `$attributes`):

```php
<h1><?php echo $a['title']; ?></h1>
<p><?php echo $a['content']; ?></p>
```

Or in Twig:

```twig
<h1>{{ a.title }}</h1>
<p>{{ a.content }}</p>
```

#### Rendering Attributes

Inside template files, all attributes can be accessed using the `$attributes` or `$a` variables and the respective ID of the field.

```php
<h1><?php echo $attributes['message']; ?></h1>
<h1><?php echo $a['message']; ?></h1>
```

```twig
<h1>{{ attributes.message }}</h1>
<h1>{{ a.message }}</h1>
```

## Empty Values

Attribute values return `false` if the field is empty or no option has been selected.

```php
<?php if ($a['message']) : ?>
  <h1><?php echo $a['message']; ?></h1>
<?php endif; ?>
```

```twig
{% if a.message %}
  <h1>{{ a.message }}</h1>
{% endif %}
```

## Complex Types

### Files

The files field returns an array with file data:

```php
<?php if ($a['image']) : ?>
  <img
    src="<?php echo $a['image']['url']; ?>"
    alt="<?php echo $a['image']['alt']; ?>"
    width="<?php echo $a['image']['width']; ?>"
    height="<?php echo $a['image']['height']; ?>"
  />
<?php endif; ?>
```

```twig
{% if a.image %}
  <img
    src="{{ a.image.url }}"
    alt="{{ a.image.alt }}"
    width="{{ a.image.width }}"
    height="{{ a.image.height }}"
  />
{% endif %}
```

### Link

The link field returns an object with URL and attributes:

```php
<?php if ($a['link']) : ?>
  <a
    href="<?php echo $a['link']['url']; ?>"
    target="<?php echo $a['link']['target']; ?>"
  >
    <?php echo $a['link']['title']; ?>
  </a>
<?php endif; ?>
```

```twig
{% if a.link %}
  <a href="{{ a.link.url }}" target="{{ a.link.target }}">
    {{ a.link.title }}
  </a>
{% endif %}
```

### Repeater

Loop through repeater items:

```php
<?php foreach ($a['items'] as $item) : ?>
  <div class="item">
    <h3><?php echo $item['title']; ?></h3>
    <p><?php echo $item['description']; ?></p>
  </div>
<?php endforeach; ?>
```

```twig
{% for item in a.items %}
  <div class="item">
    <h3>{{ item.title }}</h3>
    <p>{{ item.description }}</p>
  </div>
{% endfor %}
```

#### Filtering Attributes

Blockstudio provides two methods to filter block attributes.

## In Editor

The first method filters the attributes in the editor. This is useful if you want to adjust the default value of an attribute or its conditions.

```php
add_filter('blockstudio/block/attributes', function($attributes, $block) {
  if ($block['name'] === 'my-theme/code-block') {
    foreach ($attributes as &$attribute) {
      // Set default value
      if ($attribute['id'] === 'lineNumbers') {
        $attribute['default'] = true;
      }

      // Add condition
      if ($attribute['id'] === 'lineNumbers') {
        $attribute['conditions'] = [
          [
            [
              'id' => 'language',
              'operator' => '==',
              'value' => 'css'
            ]
          ]
        ];
      }
    }
  }
  return $attributes;
}, 10, 2);
```

The code above will set the default value of the `lineNumbers` attribute to `true` and will hide the attribute if the `language` attribute is not set to `css`.

Keep in mind that this filter is only evaluated when inserting blocks in the editor.

## On Frontend

The second method filters the attributes on the frontend. This is useful if you want to adjust the attributes before they are passed to the block template.

```php
add_filter('blockstudio/block/attributes/render', function($attributes, $block) {
  if ($block['name'] === 'my-theme/code-block') {
    // Override attribute value
    $attributes['lineNumbers'] = true;

    // Add computed value
    $attributes['formattedDate'] = date('Y-m-d');
  }
  return $attributes;
}, 10, 2);
```

Keep in mind that the above filter will override any values set in the editor.

#### Disabling Attributes

Attributes can be deactivated on a per-block basis by hovering over the left side of the UI in the sidebar and clicking when the blue border appears. This is useful when an attribute should be disabled temporarily while leaving the filled content intact.

## How It Works

1. Hover over the left edge of any attribute field in the inspector
2. A blue border will appear indicating the field can be toggled
3. Click to disable the attribute

When disabled:
- The UI appears slightly translucent
- The attribute value is preserved but not rendered
- You can re-enable it at any time

## Use Cases

- A/B Testing: Temporarily hide content without deleting it
- Draft Content: Prepare content that isn't ready to display
- Debugging: Isolate which attributes affect the output
- Client Handoff: Disable complex options for simpler editing

## Files Field

The same principle works for individual items in the files attribute type. You can disable specific images or files while keeping others active.

## Checking Disabled State

In your templates, you can check if an attribute is disabled:

```php
<?php if (!empty($a['_disabled']) && in_array('title', $a['_disabled'])) : ?>
  <!-- Title is disabled -->
<?php else : ?>
  <h1><?php echo $a['title']; ?></h1>
<?php endif; ?>
```

```twig
{% if '_disabled' in a|keys and 'title' in a._disabled %}
  {# Title is disabled #}
{% else %}
  <h1>{{ a.title }}</h1>
{% endif %}
```

Blockstudio automatically handles disabled attributes, so in most cases you don't need to check this manually - disabled attributes simply won't render.

#### Conditional Logic

Fields can be shown or hidden depending on conditions.

## Operators

There are 8 different operators which can be used:

| Operator | Description |
|----------|-------------|
| `==` | Values are equal |
| `!=` | Values are not equal |
| `includes` | Value is included in reference value |
| `!includes` | Value is not included in reference value |
| `empty` | Value is empty |
| `!empty` | Value is not empty |
| `<` | Value is smaller than reference value |
| `>` | Value is bigger than reference value |
| `<=` | Value is smaller than or equal to reference value |
| `>=` | Value is bigger than or equal to reference value |

## Global Conditions

By default, Blockstudio comes with 4 global conditions: post type, post ID, user role and user ID.

```json
{
  "$schema": "https://app.blockstudio.dev/schema",
  "name": "blockstudio/native",
  "title": "Native Block",
  "blockstudio": {
    "attributes": [
      {
        "id": "message",
        "type": "text",
        "label": "My message",
        "conditions": [
          [
            {
              "type": "postId",
              "operator": "==",
              "value": "1386"
            },
            {
              "type": "postType",
              "operator": "==",
              "value": "post"
            }
          ]
        ]
      }
    ]
  }
}
```

In the example above, the text attribute will only show in the editor if the post ID is 1386 AND the post type is post.

Note that camelCase convention is used for the type keys: `postType`, `postId`, `userRole`, `userId`.

### OR Conditions

To create or conditions, move each condition group into its own array:

```json
{
  "blockstudio": {
    "attributes": [
      {
        "id": "message",
        "type": "text",
        "label": "My message",
        "conditions": [
          [
            {
              "type": "postId",
              "operator": "==",
              "value": "1386"
            },
            {
              "type": "postType",
              "operator": "==",
              "value": "post"
            }
          ],
          [
            {
              "type": "postType",
              "operator": "==",
              "value": "jobs"
            }
          ]
        ]
      }
    ]
  }
}
```

The text attribute will show if (post ID is 1386 AND post type is post) OR (post type is jobs).

### Custom Conditions

Custom conditions can be added using the `blockstudio/blocks/conditions` filter:

```php
add_filter('blockstudio/block/conditions', function($conditions) {
  $conditions['purchasedProduct'] = function($condition) {
    // Check if user purchased the product
    return user_has_purchased($condition['value']);
  };
  return $conditions;
});
```

```json
{
  "blockstudio": {
    "attributes": [
      {
        "id": "message",
        "type": "text",
        "label": "My message",
        "conditions": [
          [
            {
              "type": "purchasedProduct",
              "operator": "==",
              "value": "1"
            }
          ]
        ]
      }
    ]
  }
}
```

## Block Conditions

You can set conditions that depend on other attributes. Instead of setting a type key, use the id of the attribute you want to check against:

```json
{
  "blockstudio": {
    "attributes": [
      {
        "type": "toggle",
        "id": "copyButton",
        "label": "Copy Button"
      },
      {
        "type": "text",
        "id": "copyButtonText",
        "label": "Copy Button Text",
        "default": "Copy",
        "conditions": [
          [
            {
              "id": "copyButton",
              "operator": "==",
              "value": true
            }
          ]
        ]
      }
    ]
  }
}
```

You can combine global conditions with block conditions as needed.

### Repeater Context

By default, conditions for attributes inside repeaters depend on the attributes of the currently repeated element.

```json
{
  "blockstudio": {
    "attributes": [
      {
        "type": "toggle",
        "id": "toggle",
        "label": "Toggle"
      },
      {
        "type": "repeater",
        "id": "repeater",
        "label": "Repeater",
        "attributes": [
          {
            "type": "toggle",
            "id": "toggle",
            "label": "Toggle"
          },
          {
            "type": "text",
            "id": "text",
            "label": "Text",
            "conditions": [
              [
                {
                  "id": "toggle",
                  "operator": "==",
                  "value": true
                }
              ]
            ]
          }
        ]
      }
    ]
  }
}
```

Since attribute IDs are scoped to the current repeater element, the text attribute inside the repeater will only show if the toggle inside the repeater is set to true.

To check against the toggle outside the repeater, add `"context": "main"` to the condition:

```json
{
  "blockstudio": {
    "attributes": [
      {
        "type": "toggle",
        "id": "toggle",
        "label": "Toggle"
      },
      {
        "type": "repeater",
        "id": "repeater",
        "label": "Repeater",
        "attributes": [
          {
            "type": "text",
            "id": "text",
            "label": "Text",
            "conditions": [
              [
                {
                  "id": "toggle",
                  "operator": "==",
                  "value": true,
                  "context": "main"
                }
              ]
            ]
          }
        ]
      }
    ]
  }
}
```

#### Populating Options

Instead of supplying different field types like Posts, Users or Terms, Blockstudio allows for a modular way of populating data right from the `block.json`. This feature works for `select`, `radio`, `checkbox`, `color` and `gradient` field types.

Data can be populated in four ways:

- Query - Return results from a post, user or term query
- Fetch - Return results from an external source
- Function - Return results from a custom function
- Custom - Return results from a custom dataset

## Query

When choosing query mode, Posts, Users or Terms can be populated.

```json
{
  "$schema": "https://app.blockstudio.dev/schema",
  "name": "blockstudio/native",
  "title": "Native Block",
  "blockstudio": {
    "attributes": [
      {
        "id": "posts",
        "type": "select",
        "label": "Posts",
        "populate": {
          "type": "query",
          "query": "posts"
        }
      }
    ]
  }
}
```

Available query types use these WordPress functions internally:

| Query | Function |
|-------|----------|
| `posts` | get_posts |
| `users` | get_users |
| `terms` | get_terms |

### Arguments

Custom arguments can be passed using the `arguments` attribute:

```json
{
  "blockstudio": {
    "attributes": [
      {
        "id": "posts",
        "type": "select",
        "label": "Posts",
        "populate": {
          "type": "query",
          "query": "posts",
          "arguments": {
            "post_type": "jobs",
            "numberposts": "20"
          }
        }
      }
    ]
  }
}
```

### Return Format

By default, Blockstudio returns:

| Query | Value | Label |
|-------|-------|-------|
| `posts` | post object | post_title |
| `users` | user object | display_name |
| `terms` | term object | name |

Customize the response with `returnFormat`:

```json
{
  "blockstudio": {
    "attributes": [
      {
        "id": "posts",
        "type": "select",
        "label": "Posts",
        "populate": {
          "type": "query",
          "query": "posts",
          "arguments": {
            "post_type": "posts",
            "numberposts": "20"
          },
          "returnFormat": {
            "value": "id",
            "label": "post_name"
          }
        }
      }
    ]
  }
}
```

### Fetch Mode

Enable dynamic searching with the `fetch` option:

```json
{
  "blockstudio": {
    "attributes": [
      {
        "id": "posts",
        "type": "select",
        "label": "Posts",
        "populate": {
          "type": "query",
          "query": "posts",
          "fetch": true,
          "arguments": {
            "post_type": "posts",
            "numberposts": "20"
          }
        }
      }
    ]
  }
}
```

This enables `stylisedUi` and fetches the first 20 posts initially. Typing in the select field searches posts using the `s` argument.

## Function

Use a custom function to populate options:

```json
{
  "blockstudio": {
    "attributes": [
      {
        "id": "postTypes",
        "type": "checkbox",
        "label": "Post types",
        "populate": {
          "type": "function",
          "function": "get_post_types"
        }
      }
    ]
  }
}
```

### Arguments

Pass arguments as an array (uses `call_user_func_array` internally):

```json
{
  "blockstudio": {
    "attributes": [
      {
        "id": "postTypes",
        "type": "checkbox",
        "label": "Post types",
        "populate": {
          "type": "function",
          "function": "get_post_types",
          "arguments": [[], "objects"]
        }
      }
    ]
  }
}
```

### Return Format

```json
{
  "blockstudio": {
    "attributes": [
      {
        "id": "postTypes",
        "type": "checkbox",
        "label": "Post types",
        "populate": {
          "type": "function",
          "function": "get_post_types",
          "arguments": [[], "objects"],
          "returnFormat": {
            "value": "name",
            "label": "label"
          }
        }
      }
    ]
  }
}
```

## Mixing Options

Combine static options with populated data:

```json
{
  "blockstudio": {
    "attributes": [
      {
        "id": "users",
        "type": "radio",
        "label": "Users",
        "options": [
          {
            "value": "administrators",
            "label": "Administrators"
          },
          {
            "value": "editors",
            "label": "Editors"
          }
        ],
        "populate": {
          "type": "query",
          "query": "users",
          "position": "before"
        }
      }
    ]
  }
}
```

The `position` option (`before` or `after`) controls where populated options appear relative to static options.

Mixing options and populate data is not supported when using fetch mode.

## Custom Data

Create reusable datasets with the `blockstudio/blocks/populate` filter:

```php
add_filter('blockstudio/block/attributes/populate', function($options, $attribute, $block) {
  if ($attribute['populate']['custom'] === 'customData') {
    return [
      ['value' => '1', 'label' => 'Option 1'],
      ['value' => '2', 'label' => 'Option 2'],
    ];
  }
  return $options;
}, 10, 3);
```

Then use it in your block:

```json
{
  "blockstudio": {
    "attributes": [
      {
        "id": "posts",
        "type": "select",
        "label": "Posts",
        "populate": {
          "type": "custom",
          "custom": "customData"
        }
      }
    ]
  }
}
```

## External Data

Fetch data from an external source:

```json
{
  "blockstudio": {
    "attributes": [
      {
        "id": "select",
        "type": "select",
        "label": "Select",
        "multiple": true,
        "populate": {
          "type": "fetch",
          "arguments": {
            "urlSearch": "https://example.com/wp-json/wp/v2/posts?search="
          },
          "returnFormat": {
            "value": "id",
            "label": "title.rendered"
          }
        }
      }
    ]
  }
}
```

The search term is appended to `urlSearch`.

#### Block Attributes

The `$attributes` or `$a` variables only give you access to data registered in the blockstudio property. To access standard WordPress block data like alignment or typography, use the `$block` or `$b` variables.

## Rendering

```php
<h1>The block is aligned: <?php echo $block['align']; ?></h1>
<h1>The block is aligned: <?php echo $b['align']; ?></h1>
```

```twig
<h1>The block is aligned: {{ block.align }}</h1>
<h1>The block is aligned: {{ b.align }}</h1>
```

## Setting Defaults

To set a default value for WordPress properties like `align`, add a `default` key inside the `attributes` key:

```json
{
  "$schema": "https://app.blockstudio.dev/schema",
  "name": "blockstudio/block",
  "title": "Native Block",
  "icon": "star-filled",
  "description": "Native Block.",
  "supports": {
    "align": ["left", "center", "right"]
  },
  "attributes": {
    "align": {
      "type": "string",
      "default": "center"
    }
  },
  "blockstudio": true
}
```

## Available Block Data

The `$block` / `$b` variable contains:

| Property | Description |
|----------|-------------|
| `name` | Block name (e.g., `my-theme/my-block`) |
| `title` | Block title |
| `dir` | Block directory path |
| `url` | Block directory URL |
| `align` | Alignment value (if `supports.align` is enabled) |
| `className` | Custom CSS class (if `supports.customClassName` is enabled) |
| `anchor` | HTML anchor/ID (if `supports.anchor` is enabled) |

## WordPress Supports

Enable WordPress block features via the `supports` property:

```json
{
  "supports": {
    "align": true,
    "anchor": true,
    "customClassName": true,
    "color": {
      "background": true,
      "text": true
    },
    "spacing": {
      "margin": true,
      "padding": true
    },
    "typography": {
      "fontSize": true,
      "lineHeight": true
    }
  }
}
```

See the WordPress Block Supports documentation for all available options.

#### Custom Fields

Custom fields let you define reusable field groups that can be referenced across multiple blocks. Think of them as field templates: define once, use everywhere.

## File System Registration

Create a `field.json` file inside a `fields/` directory in your blockstudio directory:

```
theme/
 blockstudio/
     fields/
         hero/
             field.json
```

```json
{
  "$schema": "https://app.blockstudio.dev/schema/field",
  "name": "hero",
  "title": "Hero Section",
  "attributes": [
    { "id": "heading", "type": "text", "label": "Heading", "default": "Hello World" },
    { "id": "description", "type": "textarea", "label": "Description" },
    { "id": "enabled", "type": "toggle", "label": "Enabled" }
  ]
}
```

## PHP Filter Registration

Register custom fields programmatically using the `blockstudio/fields` filter:

```php
add_filter('blockstudio/fields', function ($fields) {
    $fields['cta'] = [
        'title'      => 'Call to Action',
        'attributes' => [
            ['id' => 'text', 'type' => 'text', 'label' => 'Button Text'],
            ['id' => 'url', 'type' => 'text', 'label' => 'URL'],
        ],
    ];
    return $fields;
});
```

## Usage in block.json

Reference a custom field using the `custom/{name}` type:

```json
{
  "blockstudio": {
    "attributes": [
      { "type": "custom/hero" }
    ]
  }
}
```

This expands inline to the fields defined in the custom field definition. The expanded fields use their original IDs (`heading`, `description`, `enabled`).

## ID Structure

Use `idStructure` to prefix or transform field IDs. The `{id}` placeholder is replaced with the original field ID:

```json
{
  "blockstudio": {
    "attributes": [
      { "type": "custom/hero", "idStructure": "hero_{id}" }
    ]
  }
}
```

This produces fields with IDs: `hero_heading`, `hero_description`, `hero_enabled`.

## Overrides

Customize individual fields per-instance using `overrides`. Keys are the original field IDs from the definition:

```json
{
  "blockstudio": {
    "attributes": [
      {
        "type": "custom/hero",
        "idStructure": "hero_{id}",
        "overrides": {
          "heading": { "default": "Welcome", "label": "Title" },
          "enabled": { "id": "active" }
        }
      }
    ]
  }
}
```

Override properties are merged on top of the original field definition. An `id` override bypasses the `idStructure` pattern. In the example above, `enabled` becomes `active` instead of `hero_enabled`.

## Multiple Custom Fields

You can use multiple custom fields in a single block, alongside regular fields:

```json
{
  "blockstudio": {
    "attributes": [
      { "id": "intro", "type": "text", "label": "Intro" },
      { "type": "custom/hero", "idStructure": "hero_{id}" },
      { "type": "custom/cta", "idStructure": "cta_{id}" }
    ]
  }
}
```

## Nesting

Custom fields work inside groups, tabs, and repeaters:

```json
{
  "blockstudio": {
    "attributes": [
      {
        "type": "group",
        "id": "content",
        "title": "Content",
        "attributes": [
          { "type": "custom/hero", "idStructure": "hero_{id}" }
        ]
      }
    ]
  }
}
```

## Additional Discovery Paths

Use the `blockstudio/fields/paths` filter to add additional directories for field discovery:

```php
add_filter('blockstudio/fields/paths', function ($paths) {
    $paths[] = get_stylesheet_directory() . '/blockstudio/fields';
    return $paths;
});
```

#### HTML Utilities

Sometimes you need to use attribute values in your CSS or JS files. Blockstudio provides helper functions to render attributes as data attributes or CSS variables.

## Example Block

Let's imagine a block with the following attributes:

```json
{
  "blockstudio": {
    "attributes": [
      {
        "id": "message",
        "type": "text",
        "label": "My message"
      },
      {
        "id": "color",
        "type": "color",
        "label": "My color"
      }
    ]
  }
}
```

## Data Attributes

The `bs_render_attributes` function renders attributes as data attributes:

```php
<h1 <?php bs_render_attributes($a); ?>>
  <?php echo $a['message']; ?>
</h1>
```

```twig
<h1 {{ fn('bs_render_attributes', a) }}>
  {{ a.message }}
</h1>
```

Output:

```html
<h1 data-message="Hello" data-color="#7C3AED">
  Hello
</h1>
```

### Filtering Attributes

Pass a second parameter to specify which attributes to render:

```php
<h1 <?php bs_render_attributes($a, ['color']); ?>>
  <?php echo $a['message']; ?>
</h1>
```

```twig
<h1 {{ fn('bs_render_attributes', a, ['color']) }}>
  {{ a.message }}
</h1>
```

Output:

```html
<h1 data-color="#7C3AED">
  Hello
</h1>
```

### Return Without Rendering

Use `bs_attributes` to get the string without echoing:

```php
<?php $attrs = bs_attributes($a); ?>
```

## CSS Variables

The `bs_render_variables` function renders attributes as CSS variables:

```php
<h1 style="<?php bs_render_variables($a); ?>">
  <?php echo $a['message']; ?>
</h1>
```

```twig
<h1 style="{{ fn('bs_render_variables', a) }}">
  {{ a.message }}
</h1>
```

Output:

```html
<h1 style="--message: Hello; --color: #7C3AED;">
  Hello
</h1>
```

### Filtering Variables

```php
<h1 style="<?php bs_render_variables($a, ['color']); ?>">
```

Output:

```html
<h1 style="--color: #7C3AED;">
  Hello
</h1>
```

### Return Without Rendering

Use `bs_variables` to get the string without echoing:

```php
<?php $vars = bs_variables($a); ?>
```

## String Conversion

Both functions convert attribute IDs to kebab-case:

| Input | Output |
|-------|--------|
| `myAttribute` | `my-attribute` |
| `my_attribute` | `my-attribute` |
| `backgroundColor` | `background-color` |

## Using in CSS

```css
.my-block h1 {
  color: var(--color);
}
```

## Using in JavaScript

```javascript
const block = document.querySelector('.my-block h1');
const color = block.dataset.color;
const message = block.dataset.message;
```

### Variations

The Block Variation API allows you to register custom variations for existing blocks.

Let's imagine a block that should have two different variations depending on the value of a simple select field.

```json
{
  "$schema": "https://app.blockstudio.dev/schema",
  "name": "blockstudio/variations",
  "title": "Native Variation",
  "description": "Native Blockstudio Variation block.",
  "icon": "star-filled",
  "variations": [
    {
      "name": "variation-2",
      "title": "Native Variation 2",
      "description": "Native Blockstudio Variation block 2.",
      "attributes": {
        "select": {
          "value": "variation-2"
        }
      }
    }
  ],
  "blockstudio": {
    "attributes": [
      {
        "id": "select",
        "type": "select",
        "label": "Select",
        "options": [
          {
            "value": "variation-1",
            "label": "Variation 1"
          },
          {
            "value": "variation-2",
            "label": "Variation 2"
          }
        ],
        "default": {
          "value": "variation-1"
        }
      }
    ]
  }
}
```

The above will create three blocks in the inserter, the main one, and two variations.

## Hiding Attributes

Attributes will automatically render the appropriate input in the sidebar. Since variation blocks depend on specific attribute values, you might want to hide those fields from the sidebar. To do so, you can use the `hidden` option.

```json
{
  "blockstudio": {
    "attributes": [
      {
        "id": "select",
        "type": "select",
        "label": "Select",
        "hidden": true,
        "options": [
          {
            "value": "variation-1",
            "label": "Variation 1"
          },
          {
            "value": "variation-2",
            "label": "Variation 2"
          }
        ]
      }
    ]
  }
}
```

### Transforms

The Block Transforms API allows you to define ways in how to transform blocks. Blockstudio currently supports three different types:

- block to block: transform a block into another block
- enter: insert a block when the user enters text and presses `Enter`
- prefix: insert a block when the user enters text and presses `Space`

## Block to Block

Block to block transforms allow you to transform a block into another block.

```json
{
  "$schema": "https://app.blockstudio.dev/schema",
  "name": "blockstudio/transforms",
  "title": "Native Transforms",
  "icon": "star-filled",
  "description": "Native Blockstudio Transforms.",
  "blockstudio": {
    "transforms": {
      "from": [
        {
          "type": "block",
          "blocks": [
            "blockstudio/transforms-2",
            "blockstudio/transforms-3"
          ]
        }
      ]
    },
    "attributes": [
      {
        "id": "text",
        "type": "text",
        "label": "Text"
      }
    ]
  }
}
```

When transforming into the new block, the attributes of the old block will be passed to the new block. In the example above, the `text` attribute will be passed to the new block. The same goes for all `InnerBlocks` content.

It is important to note that the attribute types have to be the same for the block being transformed into and the block being transformed from. For example, if the block being transformed into has an attribute with the ID of `text` but the type of `number`, it won't appear in the transform list, as this would cause a type mismatch and rendering error.

The number of attributes between the two blocks doesn't have to be the same.

## Enter

Enter transforms allow you to insert a block when the user types certain content and then presses the `Enter` key.

```json
{
  "blockstudio": {
    "transforms": {
      "from": [
        {
          "type": "enter",
          "regExp": "/^-{3,}$/"
        }
      ]
    }
  }
}
```

In the example above, the block will be inserted when the user types three or more dashes (`-`) and then presses `Enter`.

## Prefix

Prefix transforms allow you to insert a block when the user types certain content and then presses the `Space` key.

```json
{
  "blockstudio": {
    "transforms": {
      "from": [
        {
          "type": "prefix",
          "regExp": "???"
        }
      ]
    }
  }
}
```

In the example above, the block will be inserted when the user types three question marks (`?`) and then presses `Space`.

### Initialization

Block templates will only be executed when the block is rendered. This is enough for most blocks; however, sometimes you need to execute code during an earlier stage of execution. For example, you may want to register a new post type or do some other type of setup unrelated to the block.

To do this, you can add a PHP file that starts with `init-`, like `init.php` or `init-post-types.php` to your block directory. This file is executed during the `init` action. For more information on this specific stage, see the WordPress documentation.

Any `init.php` file that is found within the block directory will be executed, regardless if it is part of a block context or not. This makes it perfect for organizing code snippets that are not related to any certain blocks.

## Example

```php
<?php
// Register a custom post type
register_post_type('project', [
  'labels' => [
    'name' => 'Projects',
    'singular_name' => 'Project',
  ],
  'public' => true,
  'has_archive' => true,
  'supports' => ['title', 'editor', 'thumbnail'],
]);
```

### Components

Blockstudio provides template components that map to native WordPress editor features. In the editor, they become interactive React components. On the frontend, they render as plain HTML.

- useBlockProps:Mark the block wrapper element
- InnerBlocks:Allow nested blocks within your block
- RichText:Inline rich text editing
- MediaPlaceholder:Media upload and selection

#### Components

Blockstudio provides template components that map to native WordPress editor features. In the editor, they become interactive React components. On the frontend, they render as plain HTML.

- useBlockProps:Mark the block wrapper element
- InnerBlocks:Allow nested blocks within your block
- RichText:Inline rich text editing
- MediaPlaceholder:Media upload and selection

#### useBlockProps

By default, Gutenberg has to create a wrapper around blocks to make them interactive inside the editor. This can become problematic for some block types like containers or columns, since the markup between editor and frontend will be different. The useBlockProps hook makes it possible to mark an element inside the block template as the root element, thus creating markup parity between editor and frontend.

## Usage

Simply add the `useBlockProps` attribute to the root element of your block.

```php
<div useBlockProps class="my-class">
  <!--
  This element will be rendered
  as the root element of your block
  in Gutenberg.
  -->
</div>
```

Blockstudio will automatically combine classes and attributes from the editor (alignment classes etc.) along with whatever is defined in the block templates. get_block_wrapper_attributes is being used under the hood for that.

Output:

```html
<div class="my-class wp-block-your-block-name alignright">
</div>
```

## Considerations

### Root Element

Since there can only be one root element in a block template, when using `useBlockProps`, the block template has to have a single root element. For example, the following will not work and Gutenberg will create a wrapper around the template.

```php
<div useBlockProps>
  First root element.
</div>
<span>
  Second root element.
</span>
```

Similarly, useBlockProps can only be used once per block template.

### @ Sign

Blockstudio converts the block template to valid React code inside Gutenberg using html-react-parser. This comes with the limitation that the `@` character can't be used inside an HTML attribute name.

Libraries like Alpine.js use the `@` characters to define directives on HTML elements.

```php
<button useBlockProps @click="console.log('hi')">
  Click me
</button>
```

Inside Gutenberg, this `@click` attribute will be stripped from the element. (it will still work on the frontend, of course)

To combat this issue, you can use the alternative syntax Alpine.js provides.

```php
<button useBlockProps x-on:click="console.log('hi')">
  Click me
</button>
```

The above will work inside Gutenberg and on the frontend.

#### InnerBlocks

Inner blocks allow you to insert additional blocks to your blocks. Under the
hood, Blockstudio is using the
InnerBlocks
component. Please note that it is only possible to use one InnerBlocks component
per block, this is a WordPress limitation.

## Basic Usage

To use InnerBlocks, add the `<InnerBlocks />` component to your block template:

```php
<InnerBlocks />
```

The composition is up to you. You can nest the `InnerBlocks` component as deep
as you want or just use it by itself.

## Properties

### allowedBlocks

The `allowedBlocks` prop allows you to define which blocks can be inserted into
the `InnerBlocks` component.

```php
<InnerBlocks allowedBlocks="<?php echo esc_attr(wp_json_encode(['core/heading', 'core/paragraph'])); ?>" />
```

```twig
<InnerBlocks allowedBlocks="{{ ['core/heading', 'core/paragraph']|json_encode|escape('html_attr') }}" />
```

### tag

By default, the `InnerBlocks` component is rendered as a `div` element. You can
change this by using the `tag` prop.

```php
<InnerBlocks tag="section" />
```

### template

The `template` prop allows you to define a template for the `InnerBlocks`
component.

```php
<InnerBlocks template="<?php echo esc_attr(wp_json_encode([
  ['core/heading', ['placeholder' => 'Book Title']],
  ['core/paragraph', ['placeholder' => 'Summary']]
])); ?>" />
```

```twig
<InnerBlocks template="{{ [
  ['core/heading', { placeholder: 'Book Title' }],
  ['core/paragraph', { placeholder: 'Summary' }]
]|json_encode|escape('html_attr') }}" />
```

### templateLock

The `templateLock` prop allows you to define if the template can be modified or
not.

| Value | Description |
|-------|-------------|
| `contentOnly` | Prevents all operations. Block types without content are hidden from the list view. Not overrideable by children. |
| `all` | Prevents all operations. Cannot insert, move, or delete blocks. |
| `insert` | Prevents inserting or removing blocks, but allows moving existing ones. |
| `false` | Prevents locking from being applied even if a parent block contains locking. |

### renderAppender

The `renderAppender` prop allows you to define the block appender type.

| Value | Description |
|-------|-------------|
| `default` | Display the default block appender (paragraph style appender when paragraph block is allowed) |
| `button` | Display a + icon button as the appender |

### useBlockProps

`useBlockProps` will remove the outer wrapper of the `InnerBlocks` component
inside the editor. See useBlockProps for more information.

## Context

### Registering

Blockstudio supports context for the `InnerBlocks` component. This allows you to
pass data from the parent block to the child blocks. While it uses the WordPress
core context mechanism
under the hood, Blockstudio provides a more convenient API.

Instead of having to define all attributes that should be passed in the context
separately, you can simply subscribe to all attributes of a parent block.

Let's say you have a container block setup like so:

```json
{
  "$schema": "https://app.blockstudio.dev/schema",
  "name": "blockstudio/container",
  "title": "Container",
  "category": "design",
  "icon": "star-filled",
  "description": "Container block.",
  "blockstudio": {
    "attributes": [
      {
        "id": "full-width",
        "type": "toggle",
        "label": "Makes section full width"
      }
    ]
  }
}
```

Inside your child block, simply use the `usesContext` property with the parent
block name to gain access to all parent attributes in your block template.

```json
{
  "$schema": "https://app.blockstudio.dev/schema",
  "name": "blockstudio/element",
  "title": "Element",
  "category": "design",
  "icon": "star-filled",
  "description": "Element block.",
  "usesContext": ["blockstudio/container"],
  "parent": ["blockstudio/container"],
  "blockstudio": true
}
```

### Templates

The `$context` and `$c` variables are available inside your block templates to
access all parent attributes. Child blocks will automatically reload in the
editor if parent data changes.

```php
<?php $container = $context['blockstudio/container']; ?>

<h1>
  <?php echo $container['full-width']
      ? 'is full width'
      : 'no full width'; ?>
</h1>
```

```twig
{% set container = context['blockstudio/container'] %}

<h1>
  {{ container['full-width']
      ? 'is full width'
      : 'no full width' }}
</h1>
```

## Frontend Wrapper

`InnerBlocks` has to render a wrapper element around its children inside the
editor, however, it can be removed from the frontend by using the
`blockstudio/blocks/components/innerblocks/frontend/wrap` filter.

```php
add_filter('blockstudio/block/components/innerblocks/frontend/wrap', function($wrap, $block) {
  return false; // Remove wrapper
}, 10, 2);
```

## Return Early

If you want to return early from the `render` method of your block, you can
check if the `$innerBlocks` variable is empty. This comes in handy if you don't
want to render anything if there are no inner blocks.

```php
<?php if (strip_tags($innerBlocks) === '') {
  return;
} ?>
<InnerBlocks tag="section" />
```

Since `<InnerBlocks/>` will always render an empty paragraph tag, you can use
the `strip_tags` function to check if the content is empty.

## Dynamic Templates

The Select and
Radio field types support dynamically
generating the `InnerBlocks` template depending on the field value. This is
useful if you want to allow the user to select a different template for the
`InnerBlocks` component.

To do so, simply add an `innerBlocks` key to the options array with the template:

```json
{
  "$schema": "https://app.blockstudio.dev/schema",
  "name": "blockstudio/dynamic-layout",
  "title": "Dynamic Layout",
  "blockstudio": {
    "attributes": [
      {
        "id": "layout",
        "type": "select",
        "label": "Layout",
        "options": [
          {
            "value": "1",
            "label": "Two Columns",
            "innerBlocks": [
              {
                "name": "core/columns",
                "innerBlocks": [
                  {
                    "name": "core/column",
                    "innerBlocks": [
                      {
                        "name": "core/heading",
                        "attributes": {
                          "content": "Left Heading",
                          "level": 1
                        }
                      }
                    ]
                  },
                  {
                    "name": "core/column",
                    "innerBlocks": [
                      {
                        "name": "core/heading",
                        "attributes": {
                          "content": "Right Heading",
                          "level": 1
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          },
          {
            "value": "2",
            "label": "Single Column",
            "innerBlocks": [
              {
                "name": "core/heading",
                "attributes": {
                  "content": "Main Heading",
                  "level": 1
                }
              },
              {
                "name": "core/paragraph",
                "attributes": {
                  "content": "Main content goes here."
                }
              }
            ]
          }
        ],
        "allowNull": "Select a layout"
      }
    ]
  }
}
```

#### RichText

The `RichText` component allows rendering an editable input inside the editor and a static HTML Element in the frontend. It is based on the RichText component WordPress provides.

RichText is currently not working inside repeater fields.

## Basic Usage

To use `RichText` in its most basic form, you need to add the appropriate attribute to your block.json and add the `RichText` component to your block.

```json
{
  "$schema": "https://app.blockstudio.dev/schema",
  "name": "blockstudio/rich-text",
  "title": "Native Block",
  "category": "text",
  "icon": "star-filled",
  "description": "Native Blockstudio RichText block.",
  "blockstudio": {
    "attributes": [
      {
        "id": "myRichText",
        "type": "richtext"
      }
    ]
  }
}
```

```php
<RichText attribute="myRichText" />
```

You can use an unlimited number of RichText components in your block.

## Properties

### allowedFormats

You can limit the formats that can be used in the RichText component by using the `allowedFormats` prop.

```php
<RichText attribute="myRichText" allowedFormats="<?php echo esc_attr(wp_json_encode(['core/bold', 'core/italic'])); ?>" />
```

```twig
<RichText attribute="myRichText" allowedFormats="{{ ['core/bold', 'core/italic']|json_encode|escape('html_attr') }}" />
```

### placeholder

You can set a placeholder for the RichText component by using the `placeholder` prop.

```php
<RichText attribute="myRichText" placeholder="Enter some text" />
```

### preserveWhiteSpace

Whether to preserve white space characters in the value. Normally tab, newline and space characters are collapsed to a single space. If turned on, soft line breaks will be saved as newline characters, not as line break elements.

```php
<RichText attribute="myRichText" preserveWhiteSpace="true" />
```

### tag

By default, the `RichText` content is rendered inside a `p` element. You can change this by using the `tag` prop.

```php
<RichText attribute="myRichText" tag="h1" />
```

### withoutInteractiveFormatting

By default, all formatting controls are present. This setting can be used to remove formatting controls that would make content interactive.

```php
<RichText attribute="myRichText" withoutInteractiveFormatting="true" />
```

#### MediaPlaceholder

The `MediaPlaceholder` component provides a placeholder to add media items to a block. The same component is being used in the `core/image` block. It is based on the React component with the same name.

MediaPlaceholder is currently not working inside repeater fields.

## Basic Usage

To use `MediaPlaceholder` in its most basic form, you need to add the appropriate attribute to your block.json and add the `MediaPlaceholder` component to your block.

```json
{
  "$schema": "https://app.blockstudio.dev/schema",
  "name": "blockstudio/media-placeholder",
  "title": "Native Block",
  "category": "text",
  "icon": "star-filled",
  "description": "Native Blockstudio MediaPlaceholder block.",
  "blockstudio": {
    "attributes": [
      {
        "id": "media",
        "type": "files"
      }
    ]
  }
}
```

```php
<MediaPlaceholder attribute="media" />
<?php foreach ($a['media'] as $file) {
  echo wp_get_attachment_image($file['ID']);
} ?>
```

```twig
<MediaPlaceholder attribute="media" />
{% for file in a.media %}
  {{ fn('wp_get_attachment_image', file.ID) }}
{% endfor %}
```

Once a media file has been selected, the `MediaPlaceholder` component will not be rendered anymore.

## Properties

### accept

A string passed to FormFileUpload that tells the browser which file types can be upload to the upload window the browser use e.g.: `image/` or `video/`. More information about this string is available in MDN documentation.

### allowedTypes

Array with the types of the media to upload/select from the media library. Each type is a string that can contain the general mime type e.g.: image, audio, text, or the complete mime type e.g.: `audio/mpeg`, `image/gif`. If allowedTypes is unset, all mime types should be allowed.

```php
<MediaPlaceholder allowedTypes="<?php echo esc_attr(wp_json_encode(['image', 'video'])); ?>" />
```

```twig
<MediaPlaceholder allowedTypes="{{ ['image', 'video']|json_encode|escape('html_attr') }}" />
```

### autoOpenMediaUpload

If true, the MediaUpload component auto-opens the picker of the respective platform.

### disableDropZone

If true, the Drop Zone will not be rendered. Users won't be able to drag & drop any media into the component or the block. The UI controls to upload the media via file, url or the media library would be intact.

### dropZoneUIOnly

If true, only the Drop Zone will be rendered. No UI controls to upload the media will be shown. The `disableDropZone` prop still takes precedence over `dropZoneUIOnly` - specifying both as true will result in nothing to be rendered.

### icon

Dashicon to display to the left of the title.

### isAppender

If true, the property changes the look of the placeholder to be adequate to scenarios where new files are added to an already existing set of files, e.g., adding files to a gallery. If false, the default placeholder style is used.

### disableMediaButtons

If true, only the Drop Zone will be rendered. No UI controls to upload the media will be shown.

### labels

An object that can contain a title and instructions properties.

```php
<MediaPlaceholder labels="<?php echo esc_attr(wp_json_encode(['title' => 'Custom title', 'instructions' => 'Custom instructions'])); ?>" />
```

```twig
<MediaPlaceholder labels="{{ {title: 'Custom title', instructions: 'Custom instructions'}|json_encode|escape('html_attr') }}" />
```

### Environment

Sometimes it is necessary to show content in your blocks exclusively when it is being rendered inside the Gutenberg editor and not on the frontend. This technique is very useful to provide users with helpful information and placeholders if the necessary data hasn't been input yet.

## Editor

```php
<?php if ($isEditor) : ?>
  This content is only going to be rendered inside the editor.
<?php else : ?>
  This content is only going to be rendered on the frontend.
<?php endif; ?>
```

```twig
{% if isEditor %}
  This content is only going to be rendered inside the editor.
{% else %}
  This content is only going to be rendered on the frontend.
{% endif %}
```

## Preview

Blockstudio adds another environment variable that will come in handy for block developers. `$isPreview` allows you to conditionally render content inside the block preview window when hovering over a block inside the block inserter.

```php
<?php if ($isPreview) : ?>
  This content is only going to be rendered inside the block preview.
<?php else : ?>
  This content is only going to be rendered on the frontend and editor.
<?php endif; ?>
```

```twig
{% if isPreview %}
  This content is only going to be rendered inside the block preview.
{% else %}
  This content is only going to be rendered on the frontend and editor.
{% endif %}
```

### Context

When blocks are used inside a loop (for example, a Query block), the block is executed once for each iteration of the loop. Blockstudio provides handy shortcuts for accessing the current loop and outer context.

```php
<div>
  <h1>
    This is the data of current
    element inside the loop:
    <?php echo $block['context']['postId'] ?>
    <?php echo $block['context']['postType'] ?>
  </h1>
  <h1>
    This is the data the current post:
    <?php echo $block['postId'] ?>
    <?php echo $block['postType'] ?>
  </h1>
</div>
```

```twig
<div>
  <h1>
    This is the data of current
    element inside the loop:
    {{ block.context.postId }}
    {{ block.context.postType }}
  </h1>
  <h1>
    This is the data the current post:
    {{ block.postId }}
    {{ block.postType }}
  </h1>
</div>
```

## Available Variables

Inside your block templates, you have access to these variables:

| Variable | Shorthand | Description |
|----------|-----------|-------------|
| `$attributes` | `$a` | Block attributes |
| `$block` | `$b` | Block data (name, title, postId, postType, context, etc.) |
| `$context` | `$c` | Parent block context |
| `$innerBlocks` | - | InnerBlocks content |

## Block Data

The `$block` / `$b` variable contains:

| Property | Description |
|----------|-------------|
| `name` | Block name (e.g., `my-theme/my-block`) |
| `title` | Block title |
| `dir` | Block directory path |
| `url` | Block directory URL |
| `postId` | Current post ID |
| `postType` | Current post type |
| `context` | Loop context (when inside a Query block) |

## Parent Context

When using `usesContext`, access parent block data via `$context`:

```php
<?php
$parent = $context['parent-block/name'];
echo $parent['someAttribute'];
?>
```

See InnerBlocks Context for more details.

### Preview

Gutenberg allows previewing blocks when hovering over the block in the fixed block inserter. To enable the preview of blocks made with Blockstudio, simply set the `example` key to an empty object.

```json
{
  "name": "blockstudio/native",
  "title": "Native Block",
  "category": "text",
  "icon": "star-filled",
  "description": "Native Blockstudio block.",
  "example": {},
  "blockstudio": true
}
```

## Custom Data

It is also possible to provide structured data in the `example` key, so any custom attributes are correctly being rendered.

```json
{
  "name": "blockstudio/native",
  "title": "Native Block",
  "category": "text",
  "icon": "star-filled",
  "description": "Native Blockstudio block.",
  "example": {
    "attributes": {
      "title": "This title will be shown in the preview"
    }
  },
  "blockstudio": true
}
```

```php
<h1><?php echo $a['title']; ?></h1>
```

```twig
<h1>{{ a.title }}</h1>
```

## InnerBlocks

If your block relies on `InnerBlocks`, it is possible to provide a template for the InnerBlocks.

```json
{
  "name": "blockstudio/native",
  "title": "Native Block",
  "category": "text",
  "icon": "star-filled",
  "description": "Native Blockstudio block.",
  "example": {
    "innerBlocks": [
      {
        "name": "core/paragraph",
        "attributes": {
          "content": "This is the default InnerBlocks block."
        }
      }
    ]
  },
  "blockstudio": true
}
```

### Post Meta

Since block templates are just normal PHP files, you can use any PHP code you want in them. However, since blocks don't have access to the global `$post` variable inside the editor, get_the_ID() and other functions that depend on the variable will only work on the frontend.

Blockstudio provides four different ways to access the current post ID in the editor and the frontend.

```php
echo $post_id;
echo $postId;
echo $block['postId'];
echo $b['postId'];
```

```twig
{{ post_id }}
{{ postId }}
{{ block.postId }}
{{ b.postId }}
```

## Getting Post Meta

All common custom field plugins and WordPress itself provide the possibility to access post meta using a post ID.

### ACF

```php
echo get_field('field_name', $post_id);
```

```twig
{{ fn('get_field', 'field_name', postId) }}
```

### Metabox

```php
echo rwmb_get_value('field_id', null, $post_id);
```

```twig
{{ fn('rwmb_get_value', 'field_id', postId) }}
```

## Refreshing Blocks

By default, blocks won't be refreshed when you save or update a post. Thus, old data might be displayed in the editor after saving. To fix this, you can use the `refreshOn` key inside your `block.json` to tell Blockstudio to refresh the block when a post is saved.

```json
{
  "name": "blockstudio/native",
  "title": "Native Block",
  "category": "text",
  "icon": "star-filled",
  "description": "Native Blockstudio block.",
  "blockstudio": {
    "refreshOn": [
      "save"
    ]
  }
}
```

### Storage

By default, all field values are stored as block attributes within the block comment in the post content. The storage feature allows you to additionally store values in post meta (`wp_postmeta`) or options (`wp_options`), making them accessible outside the block context.

## Why Use Storage?

Block attributes are stored inside HTML comments in the post content, which means they're only accessible when parsing block content. By using additional storage locations, you can:

- Query posts by field values using `meta_query`
- Access values via REST API for headless setups
- Share data with other plugins like SEO or caching plugins
- Create global settings that persist across posts

## Storage Types

| Type | Location | Scope | Best For |
|------|----------|-------|----------|
| `postMeta` | `wp_postmeta` table | Per post | Queryable post-specific data |
| `option` | `wp_options` table | Global (site-wide) | Site settings, shared values |

Block attribute storage (in the post content HTML comment) always happens automatically. The `storage` property adds additional storage locations - it doesn't replace block storage.

## Configuration

Add the `storage` property to any field definition:

```json
{
  "name": "blockstudio/example",
  "title": "Example Block",
  "blockstudio": {
    "attributes": [
      {
        "id": "subtitle",
        "type": "text",
        "label": "Subtitle",
        "storage": {
          "type": "postMeta",
          "postMetaKey": "my_subtitle"
        }
      }
    ]
  }
}
```

## Storage Properties

| Property | Type | Description |
|----------|------|-------------|
| `type` | `string` \| `string[]` | Additional storage location(s): `"postMeta"`, `"option"` |
| `postMetaKey` | `string` | Custom meta key (default: `{block_name}_{field_id}`) |
| `optionKey` | `string` | Custom option key (default: `{block_name}_{field_id}`) |

### Single vs Multiple Storage

```json
// Add post meta storage
"storage": {
  "type": "postMeta"
}

// Add both post meta and option storage
"storage": {
  "type": ["postMeta", "option"]
}
```

## How It Works

1. Registration: When WordPress loads, Blockstudio registers meta keys and settings based on your field configurations
2. Editing: Values are managed as block attributes in the editor (always stored in block)
3. Saving: When the post is saved, values are synced to configured storage locations

Values are synced on every post save. If you update a value in the block editor and save, all storage locations are updated automatically.

## Accessing Stored Values

### In Block Templates

Inside your block template, field values are always available via `$attributes`:

```php
<div>
  <h1><?php echo $a['subtitle']; ?></h1>
</div>
```

```twig
<div>
  <h1>{{ a.subtitle }}</h1>
</div>
```

### Post Meta (Outside Block Context)

Values stored in `postMeta` can be accessed anywhere in WordPress:

```php
// Get meta value
$subtitle = get_post_meta( $post_id, 'my_subtitle', true );

// Query posts by meta value
$posts = get_posts([
  'meta_key'   => 'my_subtitle',
  'meta_value' => 'Hello World',
]);
```

```twig
{# Using Timber #}
{{ post.meta('my_subtitle') }}

{# Or via function #}
{{ function('get_post_meta', post.id, 'my_subtitle', true) }}
```

Post meta is also available via the REST API:

```bash
GET /wp-json/wp/v2/posts/123
# Response includes: { "meta": { "my_subtitle": "Hello World" } }
```

### Options (Global Values)

Values stored in `option` are accessible site-wide:

```php
$company_name = get_option( 'site_company_name' );
```

```twig
{{ function('get_option', 'site_company_name') }}
```

## Examples

### SEO Meta Fields

Store SEO data in post meta for compatibility with SEO plugins:

```json
{
  "blockstudio": {
    "attributes": [
      {
        "id": "seo_title",
        "type": "text",
        "label": "SEO Title",
        "storage": {
          "type": "postMeta",
          "postMetaKey": "_yoast_wpseo_title"
        }
      },
      {
        "id": "seo_description",
        "type": "textarea",
        "label": "Meta Description",
        "storage": {
          "type": "postMeta",
          "postMetaKey": "_yoast_wpseo_metadesc"
        }
      }
    ]
  }
}
```

### Featured Content with Querying

Add post meta storage to enable querying posts by field value:

```json
{
  "blockstudio": {
    "attributes": [
      {
        "id": "featured",
        "type": "toggle",
        "label": "Featured",
        "storage": {
          "type": "postMeta",
          "postMetaKey": "is_featured"
        }
      }
    ]
  }
}
```

Query featured posts:

```php
$featured_posts = get_posts([
  'meta_key'   => 'is_featured',
  'meta_value' => '1',
]);
```

### Global Site Settings

Store site-wide configuration in options:

```json
{
  "blockstudio": {
    "attributes": [
      {
        "id": "company_name",
        "type": "text",
        "label": "Company Name",
        "storage": {
          "type": "option",
          "optionKey": "site_company_name"
        }
      },
      {
        "id": "support_email",
        "type": "text",
        "label": "Support Email",
        "storage": {
          "type": "option",
          "optionKey": "site_support_email"
        }
      }
    ]
  }
}
```

Access anywhere on your site:

```php
<footer>
  <p>&copy; <?php echo get_option( 'site_company_name' ); ?></p>
  <p>Contact: <?php echo get_option( 'site_support_email' ); ?></p>
</footer>
```

### Post Meta and Option

For data that needs both post-level and global accessibility:

```json
{
  "blockstudio": {
    "attributes": [
      {
        "id": "important_value",
        "type": "text",
        "label": "Important Value",
        "storage": {
          "type": ["postMeta", "option"],
          "postMetaKey": "important_meta",
          "optionKey": "important_option"
        }
      }
    ]
  }
}
```

## Default Key Names

When you don't specify a custom key, Blockstudio generates one automatically:

| Storage Type | Default Key Format | Example |
|--------------|-------------------|---------|
| `postMeta` | `{block_name}_{field_id}` | `blockstudio_example_subtitle` |
| `option` | `{block_name}_{field_id}` | `blockstudio_example_subtitle` |

The block name is sanitized (slashes replaced with underscores).

Custom keys are recommended for production use. Default keys may change if you rename your block.

### Overrides

Blockstudio includes the possibility to override blocks on a very granular level. This can be useful for shared block libraries when you want to change the behavior of a block without having to create a new block from scratch.

## block.json

To get started, set the name of the block you want to override as the `name` key and set the `override` key to `true`.

```json
{
  "name": "blockstudio/my-block",
  "title": "My overridden block title",
  "blockstudio": {
    "override": true
  }
}
```

When the `override` property is set to `true`, the data from the new `block.json` will be merged with the data from the original block. This means that you can override any property of the original block.

## Attributes

Attributes can either be overridden by `id` or added additionally. For example, let's imagine that we want to override the `width` attribute of a block and add a new `height` attribute.

```json
{
  "name": "blockstudio/my-block",
  "title": "My overridden block title",
  "blockstudio": {
    "override": true,
    "attributes": [
      {
        "id": "width",
        "type": "number",
        "default": 280,
        "label": "Override width"
      },
      {
        "id": "height",
        "type": "number",
        "default": 280,
        "label": "New height"
      }
    ]
  }
}
```

When an attribute with the same `id` is found, the data will be merged with the original attribute. Attributes which are not found will be added to the block.

When overriding attributes, you have to provide the `type` of the original attribute, even if it stays the same.

### Complex Structures

When overriding attributes with complex structures (repeaters, groups, tabs, etc.), you have to provide the full structure of the attribute to the point of the item that should be overridden.

```json
{
  "name": "blockstudio/my-block",
  "blockstudio": {
    "override": true,
    "attributes": [
      {
        "id": "tabs",
        "type": "tabs",
        "tabs": [
          {
            "id": "tab1",
            "attributes": [
              {
                "key": "group1",
                "type": "group",
                "title": "Group",
                "attributes": [
                  {
                    "id": "text",
                    "type": "text",
                    "label": "Override text"
                  }
                ]
              }
            ]
          },
          {
            "id": "tab2",
            "title": "Override tab",
            "attributes": [
              {
                "id": "group",
                "type": "group",
                "title": "Group ID",
                "attributes": [
                  {
                    "id": "text",
                    "type": "text",
                    "label": "Override text"
                  }
                ]
              }
            ]
          }
        ]
      }
    ]
  }
}
```

## Assets

Asset files will be replaced when the file name matches. For example, if a `style.css` file exists in the original block, it will be replaced by the `style.css` file in the overriding block. Files with names that do not match the original block will be added to the block.

## Rendering Template

Rendering templates can be overridden by providing a new template file, so either `index.php`, `index.twig` or `index.blade.php`.

### Twig Blocks

Twig templates can be overridden on a more granular level using the block feature in Twig.

Let's imagine the following rendering template for a fictional image block:

```twig
<h1>Images:</h1>
{% for image in a.images %}
  <div class="content">
    {% block image %}
      <img src="{{ image.url }}" class="image" />
    {% endblock %}
  </div>
{% endfor %}
```

Instead of replacing the whole template, we can use Twig's extends feature to override certain parts of the template while keeping the rest intact.

```twig
{% extends 'index.twig' %}

{% block image %}
  <figure>
    <img src="{{ image.url }}" class="image" />
    <figcaption>{{ image.caption }}</figcaption>
  </figure>
{% endblock %}
```

### Loading

Blockstudio blocks are dynamic, meaning that they must be rendered on the server to be displayed in Gutenberg. This rendering is facilitated by a `fetch` call to the Blockstudio block renderer. Upon first opening the editor, each block fetches its respective template, which results in multiple requests depending on the number of blocks present on the page.

On some hosts, this can cause timeouts and errors while loading other essential assets needed for the editor to function properly.

## Disabling

Rendering template loading can be disabled by setting the `disableLoading` key in `block.json` to `true`. A placeholder will be rendered in place of the block template. All field settings will still be available when opening the sidebar.

```json
{
  "name": "blockstudio/native",
  "title": "Native Block",
  "category": "text",
  "icon": "star-filled",
  "description": "Native Blockstudio block.",
  "blockstudio": {
    "blockEditor": {
      "disableLoading": true
    }
  }
}
```

Alternatively, block loading can be disabled globally using the `blockEditor/disableLoading` setting:

```php
add_filter('blockstudio/settings/block_editor/disable_loading', function() {
  return true;
});
```

### Programmatic Rendering

With Gutenberg becoming the prominent instrument in creating easily editable websites for clients, it makes sense to create all necessary website areas as blocks. While this approach will cater to most, advanced users and specific use cases might need to use those existing blocks outside the editor.

Blockstudio provides two specific functions for exactly this use case:

- `bs_render_block`: immediately renders the block to the page (no `echo` needed)
- `bs_block`: needs an `echo` to be rendered to the page. This function is useful when nesting blocks.

All Blockstudio specific features like inline styles, scripts, and scoped styles are supported when using the render functions.

## Without Data

In its simplest form, the function accepts a single value which is the ID of the block that should be rendered on the page.

```php
bs_render_block('blockstudio/cta');
```

## With Data

To render the block with custom data, an array needs to be used in place of a single value for the first parameter. The value in the data key will be passed to the `$attributes` and `$a` variable inside your block template.

```php
bs_render_block([
  'id' => 'blockstudio/cta',
  'data' => [
    'title' => 'My title',
    'subtitle' => 'My subtitle',
  ],
]);
```

## Nesting

Blocks can be nested within each other using the `bs_block` function in combination with the powerful `$content` variable inside your block templates.

```php
<div>
  <h1><?php echo $a['title']; ?></h1>
  <p><?php echo $a['subtitle']; ?></p>
  <?php echo $content; ?>
</div>
```

```php
echo bs_block([
  'id' => 'blockstudio/cta',
  'data' => [
    'title' => 'My title',
    'subtitle' => 'My subtitle',
  ],
  'content' => bs_block([
    'id' => 'blockstudio/button',
    'data' => [
      'text' => 'Button Text',
    ]
  ])
]);
```

The button block will be rendered in place of the `$content` variable inside the block template.

### Multiple Slots

It is also possible to create multiple content slots by simply making the `$content` variable an associative array and calling its appropriate keys in the `bs_block` function.

```php
<div>
  <?php echo $content['beforeContent']; ?>
  <h1><?php echo $a['title']; ?></h1>
  <p><?php echo $a['subtitle']; ?></p>
  <?php echo $content['afterContent']; ?>
</div>
```

```php
echo bs_block([
  'id' => 'blockstudio/cta',
  'data' => [
    'title' => 'My title',
    'subtitle' => 'My subtitle',
  ],
  'content' => [
    'beforeContent' => bs_block([
      'id' => 'blockstudio/badge',
      'data' => ['text' => 'Before Content']
    ]),
    'afterContent' => bs_block([
      'id' => 'blockstudio/button',
      'data' => ['text' => 'Button Text']
    ])
  ]
]);
```

### Interactivity

Blockstudio supports the WordPress Interactivity API, which provides a standard way to add reactive, client-side behavior to your blocks. Set `interactivity` in your block.json and Blockstudio handles loading the API on both the frontend and in the editor.

## Configuration

Enable the Interactivity API by adding `interactivity` to the `blockstudio` key in your block.json:

```json
{
  "name": "my-theme/interactive-block",
  "title": "Interactive Block",
  "category": "text",
  "icon": "star-filled",
  "description": "A block with interactive behavior.",
  "blockstudio": {
    "interactivity": true
  }
}
```

You can also use the object form:

```json
{
  "blockstudio": {
    "interactivity": {
      "enqueue": true
    }
  }
}
```

Both forms are equivalent.

## Template

Add Interactivity API directives to your block template. The `data-wp-interactive` attribute defines the store namespace, and other `data-wp-` attributes control reactive behavior.

```php
<div useBlockProps
     data-wp-interactive="myBlock"
     data-wp-context='{ "isOpen": false }'>
  <button data-wp-on--click="actions.toggle"
          data-wp-bind--aria-expanded="context.isOpen">
    Toggle
  </button>
  <div data-wp-bind--hidden="!context.isOpen">
    This content is toggled by the button.
  </div>
</div>
```

## Script

Create a `script.js` file in your block folder that imports from `@wordpress/interactivity` and initializes your store. Call `store()` at the module top level:

```js
import { store, getContext } from '@wordpress/interactivity';

store('myBlock', {
  actions: {
    toggle: () => {
      const context = getContext();
      context.isOpen = !context.isOpen;
    },
  },
});
```

Blockstudio loads `script.js` as an ES module and automatically generates the importmap needed to resolve `@wordpress/interactivity`.

A `script.js` is only needed if your block defines custom actions or callbacks. Blocks that only use declarative directives with `data-wp-context` (like `data-wp-bind--hidden` or `data-wp-text`) work without any JavaScript.

## Server-Side State

You can use `wp_interactivity_state()` in your template to initialize state from PHP:

```php
<?php
wp_interactivity_state( 'myBlock', array(
    'message' => 'Hello from the server',
    'count'   => get_comments_number(),
) );
?>
<div useBlockProps
     data-wp-interactive="myBlock">
  <p data-wp-text="state.message">loading...</p>
  <p data-wp-text="state.count">0</p>
</div>
```

Server-side state is available on the frontend only. WordPress serializes the state into a JSON script tag in the page output, which the Interactivity API reads during hydration. In the editor, blocks are rendered via the REST API, so the state data is not included in the response. Use `data-wp-context` for state that needs to work in both the editor and the frontend.

## Editor Support

The Interactivity API is loaded inside the block editor iframe, so interactive directives work in editor previews. This includes `data-wp-context`, `data-wp-bind--`, `data-wp-on--*`, `data-wp-text`, and custom store actions defined in `script.js`.

### SEO

Blockstudio blocks are dynamic. The `save` function stores attribute data but no visible text in `post_content`. This means SEO plugins that analyze editor content won't see text from Blockstudio fields by default.

Blockstudio automatically detects supported SEO plugins and injects field content into their analysis pipeline. No configuration is needed.

  Frontend SEO is unaffected. Dynamic blocks render via `render_callback`, so search engine crawlers and server-side meta generation always see the full content.

## Supported Plugins

### Yoast SEO

Blockstudio registers as a Yoast plugin and uses the `registerModification` API to append field content to the analyzed text. Changes are detected via `wp.data.subscribe` with a 1-second debounce, and Yoast's analysis refreshes automatically when content changes.

### Rank Math

Blockstudio hooks into the `rank_math_content` filter via `wp.hooks.addFilter` to append field content. Content updates follow the same debounced change detection as Yoast.

### SEOPress

SEOPress performs content analysis by rendering the actual frontend page via `wp_remote_get`. Since Blockstudio blocks render server-side through `render_callback`, SEOPress sees the full rendered output automatically. No integration code is needed.

## Other Plugins

All in One SEO (AIOSEO) runs its analysis in a Web Worker with no public API for third-party content injection.

The SEO Framework and Slim SEO focus on meta tag management and do not perform content analysis scoring.

## Analyzed Content

The integration extracts text from the following field types:

| Field Type | Extraction |
|---|---|
| `text` | Plain text value |
| `textarea` | Plain text value |
| `richtext` | HTML stripped to plain text |
| `wysiwyg` | HTML stripped to plain text |
| `link` | The `title` property |
| `repeater` | Recursively extracts from nested fields |

All other field types (number, color, toggle, files, etc.) are excluded from analysis.

## Disabled Fields

Fields listed in the block's `disabled` array are excluded from SEO analysis, matching frontend rendering behavior. When a field is disabled, it is neither rendered on the frontend nor included in the SEO content.

#### PHP Hooks

Below you'll find a list of all available PHP hooks that can be used to extend
or adjust the functionality of the plugin.

## Path

This filter allows you to adjust the path of the block folder. By default, this
is `blockstudio` inside the currently active theme. Alternatively it is possible
to create a new instance for multiple
source directories.

```php
add_filter('blockstudio/path', function() {
  $path = get_stylesheet_directory() . '/blocks';
  return $path;
});
```

## Init

### global

This action fires after the plugin has registered all blocks.

```php
add_action('blockstudio/init', function($blocks) {
  // All blocks have been registered
});
```

### instance

This action fires after the plugin has registered all blocks of a specific
instance.

```php
add_action('blockstudio/init/instance', function($blocks, $instance) {
  // All blocks of this instance have been registered
}, 10, 2);
```

### global/before

This action fires before the plugin has registered all blocks.

```php
add_action('blockstudio/init/before', function() {
  // Before blocks are registered
});
```

### global/before/instance

This action fires before the plugin has registered all blocks of a specific
instance.

```php
add_action('blockstudio/init/before/instance', function($instance) {
  // Before blocks of this instance are registered
});
```

## Blocks

### render

This filter allows you to adjust the output of a block before it is rendered.

```php
add_filter('blockstudio/block/render', function($content, $block, $attributes) {
  // Modify the block content
  return $content;
}, 10, 3);
```

### meta

This filter allows you to adjust the data of the block.json file before it is
registered.

```php
add_filter('blockstudio/block/meta', function($meta, $block) {
  if (str_starts_with($block['name'], 'marketing')) {
    $meta['icon'] = 'megaphone';
  }
  return $meta;
}, 10, 2);
```

The above code would change the icon of all blocks starting with marketing.

### conditions

This filter allows you to add custom conditions which can be used within blocks.

```php
add_filter('blockstudio/block/conditions', function($conditions) {
  $conditions['myCustomCondition'] = function($condition) {
    return $condition['value'] === 'expected';
  };
  return $conditions;
});
```

### attributes

This filter allows you to adjust the attributes of a block before the block is
registered. See Filtering for more information.

```php
add_filter('blockstudio/block/attributes', function($attributes, $block) {
  // Modify attributes before registration
  return $attributes;
}, 10, 2);
```

### attributes/render

This filter allows you to adjust the attributes of a block before it is
rendered. See Filtering for more information.

```php
add_filter('blockstudio/block/attributes/render', function($attributes, $block) {
  // Modify attributes before rendering
  return $attributes;
}, 10, 2);
```

### attributes/populate

This filter allows you to add custom data to the options of a `checkbox`,
`select` or `radio` field. See Populating options for more information.

```php
add_filter('blockstudio/block/attributes/populate', function($options, $attribute, $block) {
  if ($attribute['populate'] === 'myCustomOptions') {
    return [
      ['value' => '1', 'label' => 'Option 1'],
      ['value' => '2', 'label' => 'Option 2'],
    ];
  }
  return $options;
}, 10, 3);
```

### components/use_block_props/render

This filter allows you to adjust the output of the `useBlockProps` content.

```php
add_filter('blockstudio/blocks/components/use_block_props/render', function($props, $block) {
  $props['class'] .= ' my-custom-class';
  return $props;
}, 10, 2);
```

### components/inner_blocks/render

This filter allows you to adjust the output of the `<InnerBlocks />` content.

```php
add_filter('blockstudio/blocks/components/inner_blocks/render', function($content, $block) {
  return '<div class="inner-wrapper">' . $content . '</div>';
}, 10, 2);
```

### components/inner_blocks/frontend/wrap

This filter allows you to remove the `<InnerBlocks />` wrapper from the
frontend.

```php
add_filter('blockstudio/blocks/components/inner_blocks/frontend/wrap', function($wrap, $block) {
  return false; // Remove wrapper
}, 10, 2);
```

### components/rich_text/render

This filter allows you to adjust the output of the `<RichText />` content.

```php
add_filter('blockstudio/blocks/components/rich_text/render', function($content, $attribute, $block) {
  return wp_kses_post($content);
}, 10, 3);
```

## Settings

### path

This filter allows you to adjust the path of the `blockstudio.json` file. By
default, this is `blockstudio.json` inside the currently active theme.

```php
add_filter('blockstudio/settings/path', function() {
  return get_stylesheet_directory() . '/config/blockstudio.json';
});
```

## Assets

### enable

This filter allows you to disable the asset processing and enqueueing of a
specific asset type.

```php
add_filter('blockstudio/assets/enable', function($enable, $type, $block) {
  if ($type === 'css' && $block['name'] === 'my/block') {
    return false;
  }
  return $enable;
}, 10, 3);
```

### process/scss/import_paths

This filter allows you to add additional paths to the `@import` statement of the
SCSS compiler.

```php
add_filter('blockstudio/assets/process/scss/import_paths', function($paths) {
  $paths[] = get_stylesheet_directory() . '/scss';
  return $paths;
});
```

### process/css/content

This filter allows you to adjust the content of the CSS file before it is being
compiled.

```php
add_filter('blockstudio/assets/process/css/content', function($content, $block) {
  return str_replace('old-class', 'new-class', $content);
}, 10, 2);
```

### process/js/content

This filter allows you to adjust the content of the JS file before it is being
compiled.

```php
add_filter('blockstudio/assets/process/js/content', function($content, $block) {
  return $content;
}, 10, 2);
```

## Render

### global

This filter allows you to adjust the output of the page before it is being
rendered.

```php
add_filter('blockstudio/render', function($content) {
  return $content;
});
```

### head

This filter allows you to adjust the output of the `<head>` tag before it is
being rendered.

```php
add_filter('blockstudio/render/head', function($content) {
  return $content . '<meta name="custom" content="value">';
});
```

### footer

This filter allows you to adjust the output of the `</body>` before it is being
rendered.

```php
add_filter('blockstudio/render/footer', function($content) {
  return $content . '<script>console.log("loaded")</script>';
});
```

#### JavaScript Hooks

Blockstudio provides JavaScript hooks using the WordPress `@wordpress/hooks` package.

## Using Hooks

```javascript
import { addFilter, addAction } from '@wordpress/hooks';

// Add a filter
addFilter(
  'blockstudio.block.attributes',
  'my-plugin/modify-attributes',
  (attributes, block) => {
    // Modify attributes
    return attributes;
  }
);

// Add an action
addAction(
  'blockstudio.block.rendered',
  'my-plugin/on-rendered',
  (block) => {
    // Do something after block renders
  }
);
```

## Available Filters

### blockstudio.block.attributes

Modify block attributes before rendering.

```javascript
addFilter(
  'blockstudio.block.attributes',
  'my-plugin/modify-attributes',
  (attributes, block) => {
    return {
      ...attributes,
      customValue: 'modified'
    };
  }
);
```

### blockstudio.field.options

Modify field options dynamically.

```javascript
addFilter(
  'blockstudio.field.options',
  'my-plugin/modify-options',
  (options, field, block) => {
    if (field.id === 'mySelect') {
      return [
        ...options,
        { value: 'new', label: 'New Option' }
      ];
    }
    return options;
  }
);
```

## Available Actions

### blockstudio.block.rendered

Fires after a block is rendered in the editor.

```javascript
addAction(
  'blockstudio.block.rendered',
  'my-plugin/on-rendered',
  (block, element) => {
    console.log('Block rendered:', block.name);
  }
);
```

### blockstudio.init

Fires when Blockstudio initializes.

```javascript
addAction(
  'blockstudio.init',
  'my-plugin/on-init',
  () => {
    console.log('Blockstudio initialized');
  }
);
```

## General

Blockstudio lets you define WordPress pages and block patterns as files in your theme. Write HTML-like templates, and Blockstudio's parser converts them into native WordPress blocks.

- Pages are synced to the database as WordPress posts, keeping your file templates and page content in sync.
- Patterns are registered in memory via `register_block_pattern()`, available in the block inserter for users to place anywhere.

Both features share the same HTML parser and block syntax.

## Folder Structure

```
theme/
 pages/
    about/
       page.json
       index.php
    contact/
        page.json
        index.twig
 patterns/
     hero/
        pattern.json
        index.php
     cta/
         pattern.json
         index.blade.php
```

Each subfolder contains a JSON config file (`page.json` or `pattern.json`) and a template file.

## Template Engines

Templates can be written in PHP, Twig, or Blade:

| File | Engine | Requirement |
|------|--------|-------------|
| `index.php` | PHP | None |
| `index.twig` | Twig | Timber |
| `index.blade.php` | Blade | jenssegers/blade |

If multiple template files exist, the priority order is: `index.php` > `index.blade.php` > `index.twig`.

Since templates are compiled at initialization time (before any request context), Twig and Blade templates don't have access to dynamic variables. They're useful for built-in functions and filters like `{{ "text"|upper }}` or `{{ strtoupper("text") }}`.

## HTML to Block Mapping

Standard HTML elements are automatically converted to the corresponding WordPress blocks.

### Text

| HTML | Block |
|------|-------|
| `<p>` | `core/paragraph` |
| `<h1>` - `<h6>` | `core/heading` |
| `<ul>` | `core/list` (unordered) |
| `<ol>` | `core/list` (ordered) |
| `<li>` | `core/list-item` |
| `<blockquote>` | `core/quote` |
| `<code>` | `core/code` |
| `<pre>` | `core/preformatted` |

### Media

| HTML | Block |
|------|-------|
| `<img>` | `core/image` |
| `<figure>` | `core/image` (with caption) |
| `<audio>` | `core/audio` |
| `<video>` | `core/video` |

### Layout

| HTML | Block |
|------|-------|
| `<div>`, `<section>` | `core/group` |
| `<hr>` | `core/separator` |
| `<details>` | `core/details` |
| `<table>` | `core/table` |

## Block Syntax

For blocks that don't have a direct HTML equivalent, use the `<block>` element:

```html
<block name="core/cover" url="https://example.com/hero.jpg">
  <h1>Welcome</h1>
  <p>Content inside the cover block.</p>
</block>
```

### Core Blocks

```html
<!-- Pullquote -->
<block name="core/pullquote">
  <p>An important quote.</p>
</block>

<!-- Verse -->
<block name="core/verse">Roses are red,
Violets are blue.</block>

<!-- Cover -->
<block name="core/cover" url="https://example.com/image.jpg">
  <h2>Cover Title</h2>
</block>

<!-- Embed -->
<block name="core/embed" url="https://youtube.com/watch?v=..." providerNameSlug="youtube" />

<!-- Spacer -->
<block name="core/spacer" height="50px" />

<!-- Gallery -->
<block name="core/gallery">
  <img src="https://example.com/1.jpg" alt="Image 1" />
  <img src="https://example.com/2.jpg" alt="Image 2" />
</block>

<!-- Columns -->
<block name="core/columns">
  <block name="core/column">
    <h3>Column 1</h3>
  </block>
  <block name="core/column">
    <h3>Column 2</h3>
  </block>
</block>

<!-- Buttons -->
<block name="core/buttons">
  <block name="core/button" url="/get-started">Get Started</block>
</block>

<!-- Row (flex layout) -->
<block name="core/group" layout='{"type":"flex","flexWrap":"nowrap"}'>
  <p>Item 1</p>
  <p>Item 2</p>
</block>
```

### Custom Blocks

The same syntax works for any registered block:

```html
<block name="blockstudio/section">
  <h1>Welcome</h1>
</block>

<block name="acf/hero" title="Hero Title" background="dark">
  <p>Inner content becomes InnerBlocks.</p>
</block>
```

### Attributes

HTML attributes on `<block>` elements are passed as block attributes. JSON values are supported:

```html
<block name="core/heading" level="3">Custom Heading</block>

<block name="core/group" layout='{"type":"flex","orientation":"vertical"}'>
  <p>Stacked content.</p>
</block>

<img src="https://example.com/photo.jpg" alt="Photo" width="800" height="400" />
```

## Custom Block Renderers

The HTML parser uses a registry-based architecture. You can add custom renderers for any block using the `blockstudio/parser/renderers` filter:

```php
add_filter( 'blockstudio/parser/renderers', function( $renderers, $parser ) {
    $renderers['acf/hero'] = function( $element, $attrs, $parser ) {
        $inner_blocks = $parser->parse_children( $element );

        return array(
            'blockName'    => 'acf/hero',
            'attrs'        => $attrs,
            'innerBlocks'  => $inner_blocks,
            'innerHTML'    => '',
            'innerContent' => array(),
        );
    };

    return $renderers;
}, 10, 2 );
```

Then use it in any template:

```html
<block name="acf/hero" background="dark">
  <h1>Welcome</h1>
</block>
```

You can also override how core blocks are rendered:

```php
add_filter( 'blockstudio/parser/renderers', function( $renderers, $parser ) {
    $renderers['core/paragraph'] = function( $element, $attrs, $parser ) {
        $content = $parser->get_inner_html( $element );
        $attrs['align'] = $attrs['align'] ?? 'center';

        return array(
            'blockName'    => 'core/paragraph',
            'attrs'        => $attrs,
            'innerBlocks'  => array(),
            'innerHTML'    => '<p class="has-text-align-center">' . $content . '</p>',
            'innerContent' => array( '<p class="has-text-align-center">' . $content . '</p>' ),
        );
    };

    return $renderers;
}, 10, 2 );
```

### Renderer Function Signature

```php
/*
  @param DOMElement    $element The DOM element being parsed.
  @param array         $attrs   Attributes from the element.
  @param Html_Parser   $parser  The parser instance (for recursive parsing).
  @return array|null   WordPress block array or null to skip.
 /
function my_renderer( DOMElement $element, array $attrs, $parser ): ?array {}
```

## Element Mapping

By default, standard HTML elements like `<h1>`, `<p>`, and `<img>` map to core WordPress blocks. You can override this mapping to point any HTML element to a different block using the `blockstudio/parser/element_mapping` filter:

```php
add_filter( 'blockstudio/parser/element_mapping', function( $mapping ) {
    $mapping['h1'] = 'custom/heading';
    $mapping['h2'] = 'custom/heading';
    $mapping['p']  = 'custom/paragraph';
    $mapping['img'] = 'custom/image';

    return $mapping;
}, 10, 2 );
```

With this filter active, every `<h1>` in your templates will produce a `custom/heading` block instead of `core/heading`. The element's attributes are passed through to the target block. If a renderer is registered for the target block name, it will be used. Otherwise, a generic block structure is created.

This is useful when your theme or plugin provides custom block types that should replace the defaults across all page and pattern templates.

## Complete Example

A full page template combining multiple block types:

```html
<div>
  <h1>Welcome to Our Site</h1>
  <p>This is an <strong>introduction</strong> with <em>formatting</em>.</p>

  <block name="core/columns">
    <block name="core/column">
      <h3>Feature One</h3>
      <p>First feature description.</p>
    </block>
    <block name="core/column">
      <h3>Feature Two</h3>
      <p>Second feature description.</p>
    </block>
  </block>

  <block name="core/cover" url="https://example.com/hero.jpg">
    <h2>Our Mission</h2>
    <p>Building amazing things together.</p>
  </block>

  <details>
    <summary>FAQ</summary>
    <p>Answers to common questions.</p>
  </details>

  <block name="core/buttons">
    <block name="core/button" url="/contact">Contact Us</block>
    <block name="core/button" url="/learn-more">Learn More</block>
  </block>
</div>
```

### General

Blockstudio lets you define WordPress pages and block patterns as files in your theme. Write HTML-like templates, and Blockstudio's parser converts them into native WordPress blocks.

- Pages are synced to the database as WordPress posts, keeping your file templates and page content in sync.
- Patterns are registered in memory via `register_block_pattern()`, available in the block inserter for users to place anywhere.

Both features share the same HTML parser and block syntax.

## Folder Structure

```
theme/
 pages/
    about/
       page.json
       index.php
    contact/
        page.json
        index.twig
 patterns/
     hero/
        pattern.json
        index.php
     cta/
         pattern.json
         index.blade.php
```

Each subfolder contains a JSON config file (`page.json` or `pattern.json`) and a template file.

## Template Engines

Templates can be written in PHP, Twig, or Blade:

| File | Engine | Requirement |
|------|--------|-------------|
| `index.php` | PHP | None |
| `index.twig` | Twig | Timber |
| `index.blade.php` | Blade | jenssegers/blade |

If multiple template files exist, the priority order is: `index.php` > `index.blade.php` > `index.twig`.

Since templates are compiled at initialization time (before any request context), Twig and Blade templates don't have access to dynamic variables. They're useful for built-in functions and filters like `{{ "text"|upper }}` or `{{ strtoupper("text") }}`.

## HTML to Block Mapping

Standard HTML elements are automatically converted to the corresponding WordPress blocks.

### Text

| HTML | Block |
|------|-------|
| `<p>` | `core/paragraph` |
| `<h1>` - `<h6>` | `core/heading` |
| `<ul>` | `core/list` (unordered) |
| `<ol>` | `core/list` (ordered) |
| `<li>` | `core/list-item` |
| `<blockquote>` | `core/quote` |
| `<code>` | `core/code` |
| `<pre>` | `core/preformatted` |

### Media

| HTML | Block |
|------|-------|
| `<img>` | `core/image` |
| `<figure>` | `core/image` (with caption) |
| `<audio>` | `core/audio` |
| `<video>` | `core/video` |

### Layout

| HTML | Block |
|------|-------|
| `<div>`, `<section>` | `core/group` |
| `<hr>` | `core/separator` |
| `<details>` | `core/details` |
| `<table>` | `core/table` |

## Block Syntax

For blocks that don't have a direct HTML equivalent, use the `<block>` element:

```html
<block name="core/cover" url="https://example.com/hero.jpg">
  <h1>Welcome</h1>
  <p>Content inside the cover block.</p>
</block>
```

### Core Blocks

```html
<!-- Pullquote -->
<block name="core/pullquote">
  <p>An important quote.</p>
</block>

<!-- Verse -->
<block name="core/verse">Roses are red,
Violets are blue.</block>

<!-- Cover -->
<block name="core/cover" url="https://example.com/image.jpg">
  <h2>Cover Title</h2>
</block>

<!-- Embed -->
<block name="core/embed" url="https://youtube.com/watch?v=..." providerNameSlug="youtube" />

<!-- Spacer -->
<block name="core/spacer" height="50px" />

<!-- Gallery -->
<block name="core/gallery">
  <img src="https://example.com/1.jpg" alt="Image 1" />
  <img src="https://example.com/2.jpg" alt="Image 2" />
</block>

<!-- Columns -->
<block name="core/columns">
  <block name="core/column">
    <h3>Column 1</h3>
  </block>
  <block name="core/column">
    <h3>Column 2</h3>
  </block>
</block>

<!-- Buttons -->
<block name="core/buttons">
  <block name="core/button" url="/get-started">Get Started</block>
</block>

<!-- Row (flex layout) -->
<block name="core/group" layout='{"type":"flex","flexWrap":"nowrap"}'>
  <p>Item 1</p>
  <p>Item 2</p>
</block>
```

### Custom Blocks

The same syntax works for any registered block:

```html
<block name="blockstudio/section">
  <h1>Welcome</h1>
</block>

<block name="acf/hero" title="Hero Title" background="dark">
  <p>Inner content becomes InnerBlocks.</p>
</block>
```

### Attributes

HTML attributes on `<block>` elements are passed as block attributes. JSON values are supported:

```html
<block name="core/heading" level="3">Custom Heading</block>

<block name="core/group" layout='{"type":"flex","orientation":"vertical"}'>
  <p>Stacked content.</p>
</block>

<img src="https://example.com/photo.jpg" alt="Photo" width="800" height="400" />
```

## Custom Block Renderers

The HTML parser uses a registry-based architecture. You can add custom renderers for any block using the `blockstudio/parser/renderers` filter:

```php
add_filter( 'blockstudio/parser/renderers', function( $renderers, $parser ) {
    $renderers['acf/hero'] = function( $element, $attrs, $parser ) {
        $inner_blocks = $parser->parse_children( $element );

        return array(
            'blockName'    => 'acf/hero',
            'attrs'        => $attrs,
            'innerBlocks'  => $inner_blocks,
            'innerHTML'    => '',
            'innerContent' => array(),
        );
    };

    return $renderers;
}, 10, 2 );
```

Then use it in any template:

```html
<block name="acf/hero" background="dark">
  <h1>Welcome</h1>
</block>
```

You can also override how core blocks are rendered:

```php
add_filter( 'blockstudio/parser/renderers', function( $renderers, $parser ) {
    $renderers['core/paragraph'] = function( $element, $attrs, $parser ) {
        $content = $parser->get_inner_html( $element );
        $attrs['align'] = $attrs['align'] ?? 'center';

        return array(
            'blockName'    => 'core/paragraph',
            'attrs'        => $attrs,
            'innerBlocks'  => array(),
            'innerHTML'    => '<p class="has-text-align-center">' . $content . '</p>',
            'innerContent' => array( '<p class="has-text-align-center">' . $content . '</p>' ),
        );
    };

    return $renderers;
}, 10, 2 );
```

### Renderer Function Signature

```php
/*
  @param DOMElement    $element The DOM element being parsed.
  @param array         $attrs   Attributes from the element.
  @param Html_Parser   $parser  The parser instance (for recursive parsing).
  @return array|null   WordPress block array or null to skip.
 /
function my_renderer( DOMElement $element, array $attrs, $parser ): ?array {}
```

## Element Mapping

By default, standard HTML elements like `<h1>`, `<p>`, and `<img>` map to core WordPress blocks. You can override this mapping to point any HTML element to a different block using the `blockstudio/parser/element_mapping` filter:

```php
add_filter( 'blockstudio/parser/element_mapping', function( $mapping ) {
    $mapping['h1'] = 'custom/heading';
    $mapping['h2'] = 'custom/heading';
    $mapping['p']  = 'custom/paragraph';
    $mapping['img'] = 'custom/image';

    return $mapping;
}, 10, 2 );
```

With this filter active, every `<h1>` in your templates will produce a `custom/heading` block instead of `core/heading`. The element's attributes are passed through to the target block. If a renderer is registered for the target block name, it will be used. Otherwise, a generic block structure is created.

This is useful when your theme or plugin provides custom block types that should replace the defaults across all page and pattern templates.

## Complete Example

A full page template combining multiple block types:

```html
<div>
  <h1>Welcome to Our Site</h1>
  <p>This is an <strong>introduction</strong> with <em>formatting</em>.</p>

  <block name="core/columns">
    <block name="core/column">
      <h3>Feature One</h3>
      <p>First feature description.</p>
    </block>
    <block name="core/column">
      <h3>Feature Two</h3>
      <p>Second feature description.</p>
    </block>
  </block>

  <block name="core/cover" url="https://example.com/hero.jpg">
    <h2>Our Mission</h2>
    <p>Building amazing things together.</p>
  </block>

  <details>
    <summary>FAQ</summary>
    <p>Answers to common questions.</p>
  </details>

  <block name="core/buttons">
    <block name="core/button" url="/contact">Contact Us</block>
    <block name="core/button" url="/learn-more">Learn More</block>
  </block>
</div>
```

### Pages

Pages are file-based templates that sync to the WordPress database as posts. When you update a template file, Blockstudio detects the change and updates the corresponding page.

## page.json

Each page folder needs a `page.json` configuration file:

```json
{
  "name": "about",
  "title": "About Us",
  "slug": "about-us",
  "postType": "page",
  "postStatus": "publish",
  "templateLock": "all"
}
```

### Properties

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `name` | `string` | required | Unique identifier for the page |
| `title` | `string` | Auto from name | The page title |
| `slug` | `string` | Same as name | URL slug for the page |
| `postType` | `string` | `"page"` | WordPress post type |
| `postStatus` | `string` | `"draft"` | Status for new posts (`publish`, `draft`, `pending`, `private`) |
| `postId` | `integer` | - | Pin the page to a specific WordPress post ID |
| `blockEditingMode` | `string` | - | Block editing mode: `"default"`, `"contentOnly"`, or `"disabled"` |
| `templateLock` | `string\|false` | `"all"` | Lock mode: `"all"`, `"insert"`, `"contentOnly"`, or `false` |
| `templateFor` | `string\|null` | `null` | Set as default template for a post type |
| `sync` | `boolean` | `true` | Whether to sync content when template changes |

## Block Editing Mode

The `blockEditingMode` property controls how blocks can be edited in the editor. Set a page-level default in `page.json` and override per-element in the template:

```json
{
  "name": "about",
  "title": "About Us",
  "templateLock": "all",
  "blockEditingMode": "disabled"
}
```

```html
<h1 blockEditingMode="contentOnly">Editable Title</h1>
<p>This paragraph inherits "disabled" from the page default.</p>
<block name="core/buttons" blockEditingMode="default">
  <block name="core/button" url="/contact">Fully editable button</block>
</block>
```

| Value | Description |
|-------|-------------|
| `"default"` | Full editing. Blocks can be selected, moved, and edited |
| `"contentOnly"` | Text editing only. Block text is editable but settings and structure are locked |
| `"disabled"` | No editing. Blocks are completely non-interactive |

Per-element overrides are set as HTML attributes on any element (`<h1>`, `<p>`, `<div>`, etc.) or on `<block>` elements. Ancestor container blocks of overridden elements are automatically set to `contentOnly` so their children remain accessible.

## Template Lock

The `templateLock` property controls how users can edit the page in the editor:

| Value | Add/Remove | Move | Edit Content |
|-------|------------|------|--------------|
| `"all"` | No | No | No |
| `"insert"` | No | Yes | Yes |
| `"contentOnly"` | No | No | Yes |
| `false` | Yes | Yes | Yes |

When a `templateLock` is set, Blockstudio disables the ability to unlock blocks via the editor UI.

## Sync Behavior

Pages are synced when you visit the WordPress admin. The sync checks the file's modification time and only updates if the file has changed since the last sync.

To prevent a page from being overwritten after manual edits, set `"sync": false` in `page.json`.

## Post ID Pinning

By default, WordPress auto-assigns post IDs. If a page is deleted and re-created, the ID changes, breaking external references like menus or hardcoded links.

Use `postId` to pin a page to a specific ID:

```json
{
  "name": "about",
  "title": "About Us",
  "postId": 42
}
```

When creating the page, Blockstudio passes the ID to WordPress via `import_id`. If the ID is available, WordPress uses it exactly. If the ID is already taken by an unrelated post, WordPress silently auto-assigns a new ID.

When looking up existing pages, Blockstudio checks the pinned ID first, before checking meta or slug. This means if a page is deleted and re-synced, it reclaims the same ID.

## Keyed Block Merging

By default, when a template file changes, Blockstudio replaces the entire post content with the new template. This means any edits made in the WordPress editor are lost.

Add a `key` attribute to blocks to preserve user edits across template syncs. When a template has keyed blocks, Blockstudio merges template changes with the existing post content instead of replacing it.

### Adding Keys

Use the `key` attribute on any HTML element or `<block>` element:

```html
<h1 key="title">Default Title</h1>
<p key="intro">Default intro text.</p>

<div key="features">
  <p>First feature.</p>
  <p>Second feature.</p>
</div>

<block name="core/cover" key="hero" url="https://example.com/bg.jpg">
  <h2>Hero Title</h2>
  <p>Hero description.</p>
</block>
```

Keys must be globally unique across the entire template. A key protects the entire block and all of its content. You don't need to key individual children inside a keyed parent. Keyed blocks can be moved to any position or nesting level between template updates and their user content will still be preserved.

### How Merging Works

When a template file changes and the page re-syncs:

| Block | Behavior |
|-------|----------|
| Keyed block | User's content is preserved (innerHTML, innerContent, innerBlocks). Template's attributes are applied. |
| Unkeyed block | Replaced entirely with the template version (same as without keys) |

### Examples

User edits are preserved in keyed blocks:

1. Template defines `<p key="intro">Default intro.</p>`
2. User edits the paragraph in the editor to "Custom intro text."
3. Developer updates the template, adds a new block, changes layout
4. On sync: the paragraph keeps "Custom intro text." while the new layout is applied

Attributes from the template still apply:

1. Template has a cover block with `key="hero"` and a `url` attribute
2. Developer changes the cover's `url` attribute to a new background image
3. On sync: the new background image is applied, but user's content edits inside the cover are preserved

### Edge Cases

| Scenario | Behavior |
|----------|----------|
| New keyed block added to template | Appears with the template's default content |
| Keyed block removed from template | Deleted from the post |
| Block type changes (same key) | Template wins entirely, no content merge |
| Duplicate keys | Second occurrence is treated as unkeyed |
| No keys in template | Full replacement (same behavior as without keys) |
| Force sync | Full replacement, keys are ignored |
| Locked post | No sync at all |

### Combining with Editing Controls

Keys, `templateLock`, and `blockEditingMode` combine to give you fine-grained control over what clients can and can't do. Here are common workflow patterns.

#### Fully locked page

The developer controls everything. The page is a static layout that clients can't touch at all. Useful for legal pages, terms of service, or any page that should only change through code.

```json
{
  "name": "terms",
  "title": "Terms of Service",
  "templateLock": "all"
}
```

```html
<h1>Terms of Service</h1>
<p>Last updated: January 2025</p>
<p>These terms govern your use of our service...</p>
```

No keys needed. The template is the single source of truth. Every sync overwrites the page entirely.

#### Locked layout with editable content

The most common pattern. Lock the page structure so clients can't add, remove, or rearrange blocks, but let them edit text in specific places. Keys ensure their edits survive template updates.

```json
{
  "name": "landing",
  "title": "Landing Page",
  "templateLock": "all",
  "blockEditingMode": "disabled"
}
```

```html
<block name="core/cover" key="hero" url="https://example.com/bg.jpg">
  <h1 blockEditingMode="contentOnly">Edit This Title</h1>
  <p blockEditingMode="contentOnly">Edit this description.</p>
</block>

<div key="features">
  <h2>Features</h2>
  <p blockEditingMode="contentOnly">Editable feature intro.</p>
</div>

<block name="core/buttons">
  <block name="core/button" url="/contact">Contact Us</block>
</block>
```

The client can edit the hero title, description, and feature intro. Nothing else. The button text, URL, and cover background image are developer-controlled. When the developer updates the template (e.g., adds a second button), keyed sections keep the client's text.

#### Evolving template with preserved content

For pages that grow over time. The developer adds new sections to the template, and each sync adds the new content without touching what the client has already customized.

```html
<h1 key="title">Welcome</h1>
<p key="intro">Our introduction.</p>
<div key="services">
  <h2>Our Services</h2>
  <p>We offer great things.</p>
</div>
```

```html
<h1 key="title">Welcome</h1>
<p key="intro">Our introduction.</p>
<div key="services">
  <h2>Our Services</h2>
  <p>We offer great things.</p>
</div>
<div key="testimonials">
  <h2>Testimonials</h2>
  <p>What our clients say.</p>
</div>
<block name="core/buttons">
  <block name="core/button" url="/contact">Get in Touch</block>
</block>
```

The new testimonials section and button appear on sync. The client's edits to the title, intro, and services are untouched.

#### One-time scaffold

Create a page with a starting structure, then hand it off entirely. Set `sync` to `false` so the template is only used for the initial creation. After that, the client owns the page completely.

```json
{
  "name": "blog",
  "title": "Blog",
  "sync": false
}
```

```html
<h1>Our Blog</h1>
<p>Welcome to our blog. Start writing!</p>
```

The page is created once. After that, the client can add, remove, and rearrange blocks freely. Template changes are ignored.

## Block Bindings

An alternative to keyed merging is using WordPress core's Block Bindings API to connect blocks to post meta. This is not a Blockstudio feature, it is a native WordPress API. Blockstudio simply passes the `metadata` attribute through to the generated block markup. The content lives in post meta instead of block markup, so template syncs can freely overwrite the markup because the editor reads from meta, not from innerHTML.

Pass the `metadata` attribute on any HTML element or `<block>` element:

```html
<h1 metadata='{"bindings":{"content":{"source":"core/post-meta","args":{"key":"hero_title"}}}}'>
  Default Title
</h1>

<p metadata='{"bindings":{"content":{"source":"core/post-meta","args":{"key":"hero_description"}}}}'>
  Default description text.
</p>

<img metadata='{"bindings":{"url":{"source":"core/post-meta","args":{"key":"hero_image"}},"alt":{"source":"core/post-meta","args":{"key":"hero_image_alt"}}}}' />
```

The meta keys must be registered with `show_in_rest` enabled:

```php
register_post_meta( 'page', 'hero_title', array(
    'show_in_rest'  => true,
    'single'        => true,
    'type'          => 'string',
    'default'       => 'Default Title',
) );
```

### Keys vs. bindings

| | Keys | Bindings |
|---|---|---|
| Content stored in | Block markup (`post_content`) | Post meta (`wp_postmeta`) |
| Survives template sync | Yes (merged by key) | Yes (data lives in meta) |
| Queryable via `WP_Query` | No | Yes (`meta_query`) |
| Available in REST API | No | Yes |
| Requires registration | No | Yes (`register_post_meta`) |
| User can move blocks | No (template re-imposes structure) | No (template re-imposes structure) |

Both approaches can be used in the same template. Use keys for sections where the block structure matters (e.g., a group with multiple children). Use bindings for individual fields where you also want the data accessible outside the block editor.

## Post Type Templates

Use `templateFor` to set a page as the default template for a post type:

```json
{
  "name": "product-template",
  "title": "Product Template",
  "templateFor": "product",
  "templateLock": "insert"
}
```

Any new posts of that type will start with the defined block structure.

## Custom Paths

By default, Blockstudio scans `get_template_directory() . '/pages'`. Add additional paths with the filter:

```php
add_filter( 'blockstudio/pages/paths', function( $paths ) {
    $paths[] = get_stylesheet_directory() . '/custom-pages';
    $paths[] = MY_PLUGIN_DIR . '/pages';
    return $paths;
} );
```

## PHP API

```php
// Get all registered pages
$pages = Blockstudio\Pages::pages();

// Get a specific page
$page = Blockstudio\Pages::get_page('about');

// Get the WordPress post ID for a page
$postId = Blockstudio\Pages::get_post_id('about');

// Force sync a page (ignores modification time)
Blockstudio\Pages::force_sync('about');

// Force sync all pages
Blockstudio\Pages::force_sync_all();

// Lock a page to prevent automatic updates
Blockstudio\Pages::lock('about');

// Unlock a page
Blockstudio\Pages::unlock('about');
```

### Patterns

Patterns are file-based templates registered as WordPress block patterns. They appear in the block inserter and can be placed anywhere by users.

Unlike pages, patterns are registered in memory and don't create database entries.

## pattern.json

Each pattern folder needs a `pattern.json` configuration file:

```json
{
  "name": "hero-section",
  "title": "Hero Section",
  "description": "A hero section with heading and CTA",
  "categories": ["featured", "header"],
  "keywords": ["hero", "banner", "cta"]
}
```

### Properties

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `name` | `string` | required | Unique identifier (prefixed with `blockstudio/`) |
| `title` | `string` | required | Display title in the block inserter |
| `description` | `string` | `""` | Description shown in the inserter |
| `categories` | `string[]` | `[]` | Pattern categories (e.g., `featured`, `header`, `footer`) |
| `keywords` | `string[]` | `[]` | Search keywords for the inserter |
| `viewportWidth` | `number` | - | Preview width in pixels |
| `blockTypes` | `string[]` | `[]` | Associated block types |
| `postTypes` | `string[]` | `[]` | Restrict to specific post types |
| `inserter` | `boolean` | `true` | Whether to show in the inserter |

## Example

pattern.json:
```json
{
  "name": "hero-with-cta",
  "title": "Hero with CTA",
  "description": "A full-width hero section with heading and call-to-action buttons",
  "categories": ["featured", "header"],
  "keywords": ["hero", "banner", "cta", "landing"],
  "viewportWidth": 1200
}
```

index.php:
```html
<block name="core/cover" url="https://example.com/hero-bg.jpg" dimRatio="60">
  <h1>Build Something Amazing</h1>
  <p>Create beautiful websites with the power of blocks.</p>
  <block name="core/buttons">
    <block name="core/button" url="/get-started">Get Started</block>
    <block name="core/button" url="/learn-more" className="is-style-outline">Learn More</block>
  </block>
</block>
```

## Custom Paths

By default, Blockstudio scans `get_template_directory() . '/patterns'`. Add additional paths with the filter:

```php
add_filter( 'blockstudio/patterns/paths', function( $paths ) {
    $paths[] = get_stylesheet_directory() . '/custom-patterns';
    $paths[] = MY_PLUGIN_PATH . '/patterns';
    return $paths;
} );
```

## PHP API

```php
// Get all registered patterns
$patterns = Blockstudio\Patterns::patterns();

// Get a specific pattern
$pattern = Blockstudio\Patterns::get_pattern('hero-section');

// Get registered paths
$paths = Blockstudio\Patterns::get_registered_paths();
```

## Comparison with Pages

| | Pages | Patterns |
|---|-------|----------|
| Storage | Synced to database as posts | Registered in memory |
| Config | `page.json` | `pattern.json` |
| Sync | Auto-syncs on file change | No sync needed |
| Template lock | Yes | No |
| Use case | Predefined page content | Reusable block templates |

### Hooks

Filters and actions available for customizing pages, patterns, and the HTML parser.

## Parser

### blockstudio/parser/renderers

Filter the block renderer registry. Add custom renderers or override how blocks are parsed from HTML. See Custom Block Renderers for examples.

```php
add_filter( 'blockstudio/parser/renderers', function( $renderers, $parser ) {
    $renderers['acf/hero'] = function( $element, $attrs, $parser ) {
        $inner_blocks = $parser->parse_children( $element );

        return array(
            'blockName'    => 'acf/hero',
            'attrs'        => $attrs,
            'innerBlocks'  => $inner_blocks,
            'innerHTML'    => '',
            'innerContent' => array(),
        );
    };

    return $renderers;
}, 10, 2 );
```

## Pages

### blockstudio/pages/paths

Filter the directories scanned for page templates.

```php
add_filter( 'blockstudio/pages/paths', function( $paths ) {
    $paths[] = get_template_directory() . '/custom-pages';
    $paths[] = MY_PLUGIN_DIR . '/pages';
    return $paths;
} );
```

### blockstudio/pages/create_post_data

Filter post data before creating a new page.

```php
add_filter( 'blockstudio/pages/create_post_data', function( $post_data, $page_data ) {
    $post_data['post_author'] = 1;
    return $post_data;
}, 10, 2 );
```

### blockstudio/pages/update_post_data

Filter post data before updating an existing page.

```php
add_filter( 'blockstudio/pages/update_post_data', function( $post_data, $post, $page_data ) {
    return $post_data;
}, 10, 3 );
```

### blockstudio/pages/synced

Action fired after all pages have been synced.

```php
add_action( 'blockstudio/pages/synced', function( $registry ) {
    // $registry is the Page_Registry instance
} );
```

### blockstudio/pages/post_created

Action fired after a page post is created.

```php
add_action( 'blockstudio/pages/post_created', function( $post_id, $page_data ) {
    // Do something after page creation
}, 10, 2 );
```

### blockstudio/pages/post_updated

Action fired after a page post is updated.

```php
add_action( 'blockstudio/pages/post_updated', function( $post_id, $page_data ) {
    // Do something after page update
}, 10, 2 );
```

## Patterns

### blockstudio/patterns/paths

Filter the directories scanned for pattern templates.

```php
add_filter( 'blockstudio/patterns/paths', function( $paths ) {
    $paths[] = get_stylesheet_directory() . '/custom-patterns';
    $paths[] = MY_PLUGIN_PATH . '/patterns';
    return $paths;
} );
```

### blockstudio/patterns/registered

Action fired after all patterns have been registered.

```php
add_action( 'blockstudio/patterns/registered', function( $registry ) {
    // $registry is the Pattern_Registry instance
} );
```

### Tailwind CSS

Blockstudio includes built-in Tailwind CSS v4 support. When enabled, every frontend page is compiled server-side via TailwindPHP with automatic file-based caching. In the block editor, a bundled Tailwind CDN script provides live preview as you edit.

No build step, no CLI, no Node.js required.

## How It Works

Blockstudio uses two separate compilation strategies depending on the context:

### Frontend (Server-Side)

On every frontend request, Blockstudio captures the full page HTML through an output buffer, extracts all CSS class candidates, compiles only the CSS that is actually used, and injects the result as an inline `<style>` tag before `</head>`.

The compilation flow:

1. WordPress renders the full page HTML into an output buffer
2. `TailwindPHP::extractCandidates()` scans the HTML and extracts all potential CSS class names (fast regex, no compilation)
3. The sorted candidates are hashed together with the CSS config to create a cache key
4. On cache hit: the compiled CSS is read from disk and injected
5. On cache miss: `TailwindPHP::generate()` compiles the CSS, writes it to the cache directory, and injects it

The compiled CSS is injected as:

```html
<style id="blockstudio-tailwind">/ compiled CSS /</style>
```

This includes Tailwind's preflight (CSS reset) and all matched utility classes.

### Editor (Client-Side)

Inside the block editor, a bundled Tailwind CDN script (browser build of Tailwind CSS v4) runs client-side. This provides instant live preview as you type class names, without any server round-trips. The CDN is only loaded in the editor and is never served on the frontend.

## Enabling Tailwind

Add the `tailwind` configuration to your `blockstudio.json`:

```json
{
  "$schema": "https://app.blockstudio.dev/schema/blockstudio",
  "tailwind": {
    "enabled": true
  }
}
```

Or enable it via a filter:

```php
add_filter('blockstudio/settings/tailwind/enabled', '__return_true');
```

When `enabled` is `true`, every frontend page will have Tailwind CSS compiled and injected automatically. You can use Tailwind utility classes anywhere: in block templates, theme templates, `the_content` filters, or any HTML that appears in the page output.

## Configuration

Tailwind v4 uses a CSS-first configuration approach. Instead of a JavaScript config file, you write configuration directly as CSS using the `@theme` directive.

```json
{
  "tailwind": {
    "enabled": true,
    "config": "@theme { --color-primary: #3b82f6; --color-secondary: #10b981; --font-family-heading: 'Inter', sans-serif; }"
  }
}
```

The `config` value is a CSS string that gets appended after the `@import "tailwindcss"` directive. You can use any valid Tailwind v4 CSS syntax here:

```json
{
  "tailwind": {
    "enabled": true,
    "config": "@theme { --color-brand: oklch(0.7 0.15 200); } @layer base { h1 { font-size: var(--text-4xl); } }"
  }
}
```

For multiline configs, the filter approach is more ergonomic:

```php
add_filter('blockstudio/settings/tailwind/config', function () {
    return <<<CSS
@theme {
    --color-primary: #3b82f6;
    --color-secondary: #10b981;
    --font-family-heading: 'Inter', sans-serif;
    --breakpoint-xs: 30rem;
}

@layer base {
    body {
        font-family: var(--font-family-sans);
    }
}

@layer utilities {
    .btn { @apply px-4 py-2 rounded-lg font-medium; }
    .btn-primary { @apply bg-blue-500 text-white hover:bg-blue-600; }
    .card { @apply bg-white rounded-xl shadow-lg p-6; }
}
CSS;
});
```

### Custom Utility Classes

To define reusable class aliases, use `@layer utilities` with Tailwind's `@apply` directive directly in your config string:

```json
{
  "tailwind": {
    "enabled": true,
    "config": "@theme { --color-brand: #6366f1; } @layer utilities { .btn { @apply px-4 py-2 rounded-lg font-medium; } .section { @apply py-16 px-4 max-w-7xl mx-auto; } }"
  }
}
```

This compiles these classes alongside all standard Tailwind utilities. They work both on the frontend (server-side compilation) and in the editor (CDN preview).

## Classes Field Type

To use Tailwind classes in a block's `classes` field with autocomplete support, set `tailwind: true` on the field:

```json
{
  "name": "my-theme/hero",
  "title": "Hero",
  "blockstudio": {
    "attributes": [
      {
        "id": "classes",
        "type": "classes",
        "label": "Classes",
        "tailwind": true,
        "default": "bg-white text-gray-900"
      }
    ]
  }
}
```

When `tailwind` is `true`:

- The field provides autocomplete suggestions from the full Tailwind class list
- The Tailwind CDN script is loaded in the editor for live preview
- Classes are stored as a space-separated string in the block attributes

Use the classes value in your template:

```php
<div class="<?php echo $a['classes']; ?>">
  <!-- block content -->
</div>
```

## Settings Reference

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `enabled` | boolean | `false` | Enable Tailwind CSS compilation on the frontend |
| `config` | string | `""` | Tailwind v4 CSS-first configuration string |

### Setting via JSON

```json
{
  "tailwind": {
    "enabled": true,
    "config": "@theme { --color-brand: pink; }"
  }
}
```

### Setting via Filters

```php
add_filter('blockstudio/settings/tailwind/enabled', '__return_true');

add_filter('blockstudio/settings/tailwind/config', function () {
    return '@theme { --color-brand: pink; }';
});
```

## Caching

Blockstudio uses a custom caching strategy designed for Tailwind's utility-based architecture.

### How the Cache Works

Rather than hashing the entire page HTML (which would bust the cache on every request due to nonces, timestamps, and other dynamic content), Blockstudio extracts only the CSS class candidates from the HTML. These candidates are sorted and hashed together with the CSS configuration to produce a stable cache key.

This means:

- Two pages that use the same set of Tailwind classes share the same cached CSS file, even if their HTML is completely different
- Dynamic content like nonces, logged-in user bars, comment counts, and timestamps do not bust the cache
- The cache only invalidates when the set of CSS classes on a page changes or the Tailwind config changes

### Cache Location

Cache files are stored in:

```
wp-content/uploads/blockstudio/tailwind/cache/
```

Each file is named with an MD5 hash: `{hash}.css`.

### Clearing the Cache

Delete the contents of the cache directory to force recompilation:

```php
// Clear all cached Tailwind CSS
$cache_dir = wp_upload_dir()['basedir'] . '/blockstudio/tailwind/cache';
array_map('unlink', glob("$cache_dir/.css"));
```

Or via WP-CLI:

```bash
wp eval "array_map('unlink', glob(wp_upload_dir()['basedir'] . '/blockstudio/tailwind/cache/.css'));"
```

The next frontend request will recompile and cache the CSS automatically.

## Filters

### `blockstudio/tailwind/css`

Modify the CSS input before compilation. The CSS input string starts with `@import "tailwindcss";`, followed by any config. Use this filter to add additional CSS directives, custom `@layer` rules, or plugin imports.

```php
add_filter('blockstudio/tailwind/css', function (string $css): string {
    // Add a custom utility
    $css .= "\n@utility container-narrow { max-width: 48rem; margin-inline: auto; }";

    return $css;
});
```

The full CSS input that gets compiled looks like this:

```css
/ Base import /
@import "tailwindcss";

/ Config from settings (if set) /
@theme { --color-brand: pink; }

/ Anything added via the blockstudio/tailwind/css filter /
```

## Output Buffer

Tailwind compilation hooks into Blockstudio's output buffer system. The buffer captures the complete page HTML after WordPress has finished rendering, allowing Tailwind to scan all classes from every source: block templates, theme templates, plugin output, `the_content` filters, and widget areas.

The compilation filter runs at priority `999999` on the `blockstudio/buffer/output` hook, ensuring it processes the final HTML after all other modifications. The buffer is started on the `template_redirect` action, which means it only runs on frontend requests, not in the admin, REST API, or AJAX contexts.

## Architecture

```
Frontend Request
  
   WordPress renders HTML into output buffer
  
   blockstudio/buffer/output filter (priority 999999)
     
      Settings::get('tailwind/enabled')  false? Return HTML unchanged
     
      build_css_input()
         @import "tailwindcss"
         + tailwind/config setting
         + blockstudio/tailwind/css filter
     
      TailwindPHP::extractCandidates($html)
         Returns array of CSS class names found in HTML
     
      Cache key = md5(sorted candidates + css input)
     
      Cache hit?
         Yes  Read CSS from uploads/blockstudio/tailwind/cache/{hash}.css
         No   TailwindPHP::generate()  Write to cache file
     
      Inject <style id="blockstudio-tailwind"> before </head>
  
   Browser receives HTML with compiled CSS

Editor Request
  
   Admin loads block editor
  
   Block with classes field (tailwind: true) detected
      Block_Registry::set_tailwind_active(true)
  
   Admin passes isTailwindActive + tailwindUrl to JS
  
   useTailwind() hook
       Injects Tailwind CDN script into document
       Creates hidden template div with HTML content
       Creates style tag for config
       CDN compiles CSS in-browser for live preview
```

## Full Example

A complete working setup with custom theme colors and a block that uses them:

```json
{
  "$schema": "https://app.blockstudio.dev/schema/blockstudio",
  "tailwind": {
    "enabled": true,
    "config": "@theme { --color-brand: #6366f1; --color-brand-light: #a5b4fc; --color-surface: #f8fafc; } @layer utilities { .section-padding { @apply py-20 px-6; } .content-width { @apply max-w-5xl mx-auto; } .heading-xl { @apply text-4xl font-bold tracking-tight; } }"
  }
}
```

```json
{
  "name": "my-theme/hero",
  "title": "Hero Section",
  "blockstudio": {
    "attributes": [
      {
        "id": "title",
        "type": "text",
        "label": "Title",
        "default": "Welcome"
      },
      {
        "id": "wrapperClasses",
        "type": "classes",
        "label": "Wrapper Classes",
        "tailwind": true,
        "default": "section-padding bg-surface"
      },
      {
        "id": "titleClasses",
        "type": "classes",
        "label": "Title Classes",
        "tailwind": true,
        "default": "heading-xl text-brand"
      }
    ]
  }
}
```

```php
<section class="<?php echo $a['wrapperClasses']; ?>">
  <div class="content-width">
    <h1 class="<?php echo $a['titleClasses']; ?>">
      <?php echo esc_html($a['title']); ?>
    </h1>
  </div>
</section>
```

This renders on the frontend with all Tailwind utilities and custom theme colors compiled into a single inline `<style>` tag.

### Extensions

Extensions allow you to extend any registered block in your WordPress installation using a simple `.json` based API, which is similar to the `block.json` configuration. This includes core, third-party and blocks made with Blockstudio.

All field types can be added to any block, with the data being saved to the block's attributes. The complete feature set of attributes like filtering, disabling, conditional logic and populating options are available for extensions.

## Extension Types

Extended values can be utilized in versatile ways:

- class: Add a class using the attribute value to the block
- style: Add inline styles using the attribute value to the block
- attributes: Set any attribute value directly on the block
- data attributes: Use extension values to set specific data attributes

## Setup

Imagine the following scenario: you want to add a custom class `select` field to every core block. All you need to do is add this `.json` file anywhere in your block folder, and it will be automatically registered as an extension.

```json
{
  "$schema": "https://app.blockstudio.dev/schema/extend",
  "name": "core/",
  "priority": 10,
  "blockstudio": {
    "extend": true,
    "attributes": [
      {
        "id": "customColor",
        "type": "select",
        "label": "Custom color",
        "options": [
          {
            "value": "#f00",
            "label": "Red"
          },
          {
            "value": "#00f",
            "label": "Blue"
          }
        ],
        "set": [
          {
            "attribute": "style",
            "value": "color: {attributes.customColor}"
          }
        ]
      }
    ]
  }
}
```

This will add a `customColor` field to every core block, allowing you to set the color of the block's text.

### File Name

Since there is no rendering template, an extension doesn't need a matching `index` file and thus doesn't need to be named `block.json`. This allows storing all extensions conveniently in a single folder.

### Schema

Blockstudio provides a custom JSON schema for extension configurations:

View Extension schema

### Name

The `name` property of the configuration object defines which blocks should be extended. There are three options depending on your needs:

- blockName: A single block name, e.g. `core/paragraph`
- [blockNameA, blockNameB]: An array of block names, e.g. `["core/paragraph", "core/heading"]`
- core/\: A wildcard to extend all blocks of a certain type

### Blockstudio Key

Just like when using `block.json` for custom blocks, the `blockstudio` property has to be present in the configuration object with `extend` set to `true`.

### Position

By default, extensions will render in its own tab in the block inspector. If you want to move the extensions to a different position, you can use the `group` property:

- settings: The default position
- styles: The styles tab
- advanced: The advanced tab

```json
{
  "$schema": "https://app.blockstudio.dev/schema/extend",
  "name": "core/",
  "blockstudio": {
    "extend": true,
    "group": "styles",
    "attributes": []
  }
}
```

### Priority

The `priority` property allows you to define the order in which extensions are rendered. Extensions with a higher priority will be rendered later.

## Attributes

For more information on how attributes work, please refer to the attributes section.

The only thing you need to know about attributes inside extensions is the `set` property. It is used to apply the value of the attribute to one of the extension types.

```json
{
  "$schema": "https://app.blockstudio.dev/schema/extend",
  "name": "core/",
  "blockstudio": {
    "extend": true,
    "attributes": [
      {
        "id": "customColor",
        "type": "select",
        "label": "Heading color",
        "options": [
          {
            "value": "#f00",
            "label": "Red"
          },
          {
            "value": "#00f",
            "label": "Blue"
          }
        ],
        "set": [
          {
            "attribute": "style",
            "value": "color: {attributes.customColor}"
          }
        ]
      }
    ]
  }
}
```

### Getting Values

Dot notation inside curly braces is used to get the value of an attribute.

It is also possible to get nested values when attributes are not returning a single value, for example, when setting the return format to `both` on field types with options.

```json
{
  "attributes": [
    {
      "id": "customColor",
      "type": "select",
      "label": "Heading color",
      "options": [
        {
          "value": "#f00",
          "label": "Red"
        },
        {
          "value": "#00f",
          "label": "Blue"
        }
      ],
      "returnFormat": "both",
      "set": [
        {
          "attribute": "style",
          "value": "color: {attributes.customColor.value}"
        },
        {
          "attribute": "data-color",
          "value": "{attributes.customColor.label}"
        }
      ]
    }
  ]
}
```

The example above will set the `style` attribute to `color: #f00` or `color: #00f` and the `data-color` attribute to `Red` or `Blue` depending on the value.

For now, only values from the current attribute can be used inside `set` definitions. The ability to use values from other attributes might be added in the future.

### Arrays

When using arrays, the `set` property will be applied to every item in the array.

### Attributes Field

When using the `attributes` field, there is no `set` property needed, as the field automatically maps the values to the attribute name and value.

### Code Snippets

Although Blockstudio's main focus is on custom blocks, its file-first approach is also suitable for code snippets.

## Setup

To create a new code snippet, simply create a new folder and place an `init.php` file in it. Blockstudio will always execute that file. For more information on the init file, check the Initialization page.

## Styles and Scripts

Folders marked as code snippets will also process and enqueue styles and scripts. To enqueue global styles and scripts, use the `global` prefix for the asset name.

Example folder structure:

```
assets/
 init.php
 global-styles.css
 global-scripts.js
```

Assets inside code snippet folders also support all processing.

## Custom Directories

The above technique can also be used on directories outside of the folder where all blocks are stored. For example, let's say you want to store global assets like styles and scripts inside your theme. Simply create a new Blockstudio instance using the `init` method.

```php
add_action('init', function () {
  Blockstudio\Build::init([
    'dir' => get_template_directory() . '/assets'
  ]);
});
```

Now, simply follow the setup instructions to register a code snippet inside the `assets` folder.

### Canvas

The canvas provides a zoomed-out, Figma-like overview of all Blockstudio-managed pages. Each page renders as a live iframe artboard in a single horizontal row. Pan with your trackpad, zoom with pinch or Ctrl+scroll, and press Escape to exit.

## Activation

Append `?blockstudio-canvas` to any frontend URL to enter the canvas:

```
https://example.com/?blockstudio-canvas
https://example.com/my-page/?blockstudio-canvas
```

Without the query parameter, no canvas script is loaded.

## Settings

Enable the canvas and configure its behavior in your theme's `blockstudio.json`:

```json
{
  "dev": {
    "canvas": {
      "enabled": true,
      "adminBar": false
    }
  }
}
```

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `enabled` | `boolean` | `false` | Enable the canvas feature. |
| `adminBar` | `boolean` | `true` | Show the WordPress admin bar inside artboard iframes. Set to `false` for a cleaner preview. |

Both settings are also available as filters:

```php
add_filter('blockstudio/settings/dev/canvas/enabled', '__return_true');
add_filter('blockstudio/settings/dev/canvas/admin_bar', '__return_false');
```

## Controls

| Action | Input |
|--------|-------|
| Pan | Scroll / trackpad two-finger drag |
| Zoom | Ctrl+scroll or pinch |

## Security

The canvas script and page data are only loaded when all conditions are met:

- The `?blockstudio-canvas` query parameter is present.
- The `dev.canvas.enabled` setting is `true`.
- The current user has the `edit_posts` capability.

Public visitors never see the canvas script or page metadata.

### Element Grabber

When working with AI coding assistants, you often need to tell them which template file renders a specific element on the page. The element grabber provides a crosshair-style element selector that copies rich element context to your clipboard with a single gesture.

## Activation

The element grabber is gated behind a query parameter. Append `?blockstudio-devtools` to any frontend URL to enable it:

```
https://example.com/?blockstudio-devtools
https://example.com/?p=123&blockstudio-devtools
```

Without the query parameter, no script or data attributes are loaded.

## Settings

Enable the element grabber in your theme's `blockstudio.json`:

```json
{
  "dev": {
    "grab": {
      "enabled": true
    }
  }
}
```

| Property | Type | Default | Description |
|----------|------|---------|-------------|
| `enabled` | `boolean` | `false` | Enable the element grabber. |

The setting is also available as a filter:

```php
add_filter('blockstudio/settings/dev/grab/enabled', '__return_true');
```

## Usage

1. Visit any frontend page with `?blockstudio-devtools` while logged in as a user with `edit_posts` capability.
2. Hold Cmd+C (Mac) or Ctrl+C (Windows) for 100ms to activate the grabber.
3. A crosshair selector activates with a canvas overlay highlighting Blockstudio blocks as you hover.
4. Two labels appear: one showing the block's template file path and one showing the HTML element tag name.
5. Click an element to copy its context to your clipboard.
6. Paste the result into your AI coding tool.

Press Escape or Cmd+C again to deactivate without copying. If you release Cmd+C before 100ms, normal copy behavior is preserved.

## Clipboard Format

Clicking an element copies a rich context string designed for AI coding assistants:

```
@<div>

<div class="my-block">
  Hello world
</div>
  in theme-name/blockstudio/blocks/my-block/index.php
```

This includes the element tag name, an HTML preview with attributes and content, and the template file path.

## Internals

Blockstudio adds a `data-blockstudio-path` attribute to every block wrapper element that uses `useBlockProps` on the frontend. This attribute contains the absolute path to the template file that renders the block.

A lightweight vanilla TypeScript module (no React, no WordPress dependencies) is enqueued on the frontend for logged-in editors. It uses `document.elementsFromPoint()` to detect both the specific HTML element under the cursor and its parent Blockstudio block, drawing separate highlights for each.

## Security

The `data-blockstudio-path` attribute and grabber script are only rendered when all conditions are met:

- The `?blockstudio-devtools` query parameter is present.
- The `dev.grab.enabled` setting is `true`.
- The current user has the `edit_posts` capability.

Public visitors never see file paths or the grabber script.

### Composer

Blockstudio is available as a Composer package. This is the recommended way to install it in managed WordPress projects.

## Installation

```bash
composer require blockstudio/blockstudio
```

The package is published on Packagist.

## Embedding in Plugins and Themes

Blockstudio is fully namespaced and uses a singleton pattern, so it can be safely embedded within other plugins or themes without class name collisions. If you are building a plugin or theme that bundles Blockstudio, require it in your project's `composer.json`:

```json
{
  "name": "my-company/my-plugin",
  "require": {
    "blockstudio/blockstudio": "^7.0"
  }
}
```

The singleton pattern ensures only one instance runs, even if multiple plugins bundle Blockstudio. Namespacing prevents conflicts with other libraries in the WordPress environment.

## Schemas

### Block Schema (blockstudio key from block.json)

```json
{"definitions":{"Attribute":{"type":"object","required":["type"],"properties":{"id":{"type":"string","description":"A unique identifier for the field, which will be used get the value inside block templates. Must be unique within the current context."},"key":{"type":"string","description":"Another identifier that can be used to uniquely identify fields across different contexts. (inside repeaters etc.)"},"type":{"type":"string","anyOf":[{"enum":["attributes","checkbox","classes","code","color","date","datetime","files","gradient","icon","link","message","number","radio","range","select","tabs","text","textarea","toggle","repeater","richtext","unit","wysiwyg"]},{"pattern":"^custom/.+$","description":"Custom field reference in format 'custom/{name}'."}]},"label":{"type":"string","description":"The label for the field."},"description":{"type":"string","description":"The description for the field. Will be displayed underneath the field."},"help":{"type":"string","description":"The help text for the field. Will be displayed in a tooltip next to the label."},"hidden":{"type":"boolean","description":"Whether to hide the field UI in the editor. This is handy when using the variations API."},"storage":{"type":"object","description":"Configure where the field value should be stored.","properties":{"type":{"type":["string","array"],"description":"Storage location(s). Can be a single type or array of types.","enum":["block","postMeta","option"]},"postMetaKey":{"type":"string","description":"Custom meta key for post meta storage. Defaults to {block_name}_{field_id}."},"optionKey":{"type":"string","description":"Custom option key for options storage. Defaults to {block_name}_{field_id}."}}},"switch":{"type":"boolean","description":"Display a toggle that can disable the field. Shows an eye icon in the field label. Defaults to false.","default":false},"idStructure":{"type":"string","description":"ID pattern for expanded custom fields. Use {id} as placeholder for the original field ID.","default":"{id}","example":"hero_{id}"},"overrides":{"type":"object","description":"Per-field property overrides for custom fields. Keys are original field IDs from the field definition.","additionalProperties":{"type":"object"}},"conditions":{"type":"array","description":"Conditional logic detailing when the field should be displayed in the editor.","items":{"type":"array","items":{"type":"object","required":["operator"],"properties":{"id":{"type":"string","description":"ID of the field whose value will be used for the conditionally render it."},"operator":{"type":"string","description":"How the values should be compared.","enum":["==","!=","includes","!includes","empty","!empty","<",">","<=",">="]},"type":{"type":"string","description":"Condition type."},"value":{"type":["string","number","boolean"],"description":"Value that will be compared."}}}}}},"anyOf":[{"example":"attributes","description":"Renders data attribute inputs.","properties":{"type":{"const":"attributes"},"default":{"type":"array","description":"Default value that should be applied when first adding the block."},"fallback":{"type":"array","description":"Fallback value that that will display when field value is empty."},"link":{"type":"boolean","description":"Enables link selection from dropdown."},"media":{"type":"boolean","description":"Enables media selection from dropdown."}}},{"example":"option-multiple","description":"Renders a set of checkbox inputs.","properties":{"type":{"const":"checkbox"},"default":{"type":["array","string","number"],"description":"Default value that should be applied when first adding the block."},"fallback":{"type":["array","string","number"],"description":"Fallback value that that will display when field value is empty."},"options":{"type":"array","items":{"type":"object","properties":{"label":{"type":"string"},"value":{"type":["string","number"]}},"required":["value"]},"description":"Options to choose from."},"returnFormat":{"type":"string","description":"Specifies the return format value.","enum":["value","label","both"],"default":"value"},"populate":{"type":"object","properties":{"function":{"type":"string","description":"The function that should be executed."},"type":{"type":"string","enum":["query","function","custom","fetch"]},"query":{"type":"string","enum":["posts","users","terms"],"description":"Type of query that should be used to fetch data."},"arguments":{"type":["object","array"],"description":"Query or fetch arguments.","properties":{"urlSearch":{"type":"string","description":"Search URL when using the \"fetch\" type."}}},"custom":{"type":"string","description":"Custom data ID."},"position":{"type":"string","description":"How the data should be positioned in regards to the default options.","enum":["before","after"],"default":"after"},"returnFormat":{"type":"object","description":"Format of the returning data when using objects.","properties":{"value":{"type":"string"},"label":{"type":"string"}}}}}}},{"example":"single","description":"Renders a field to select CSS classes.","properties":{"type":{"const":"classes"},"default":{"type":["string"],"description":"Default value that should be applied when first adding the block."},"fallback":{"type":["string"],"description":"Fallback value that that will display when field value is empty."},"tailwind":{"type":"boolean","description":"Whether to enable Tailwind classes for this input field."}}},{"example":"single","description":"Renders a code editor.","properties":{"type":{"const":"code"},"default":{"type":"string","description":"Default value that should be applied when first adding the block."},"fallback":{"type":"string","description":"Fallback value that that will display when field value is empty."},"autoCompletion":{"type":"boolean","description":"Whether to enable autocompletion or not."},"foldGutter":{"type":"boolean","description":"Whether to show the fold gutter or not."},"height":{"type":"string","description":"The height of the editor."},"language":{"type":"string","description":"The language to use for syntax highlighting.","enum":["css","html","javascript","json","twig"]},"lineNumbers":{"type":"boolean","description":"Whether to display line numbers or not."},"maxHeight":{"type":"string","description":"The maximum height of the editor."},"minHeight":{"type":"string","description":"The minimum height of the editor."},"popout":{"type":"boolean","description":"Whether to show a button that opens the editor in a popup window."}}},{"example":"option","description":"Renders a color palette and color picker.","properties":{"type":{"const":"color"},"options":{"type":"array","default":{"type":"array","description":"Default value that should be applied when first adding the block."},"fallback":{"type":"array","description":"Fallback value that that will display when field value is empty."},"items":{"type":"object","properties":{"name":{"type":"string"},"value":{"type":"string"},"slug":{"type":"string"}},"description":"Options to choose from."}},"populate":{"type":"object","properties":{"function":{"type":"string","description":"The function that should be executed."},"type":{"type":"string","enum":["function","custom"]},"custom":{"type":"string","description":"Custom data ID."},"position":{"type":"string","description":"How the data should be positioned in regards to the default options.","enum":["before","after"],"default":"after"}}},"clearable":{"type":"boolean","description":"Whether the palette should have a clearing button or not."},"disableCustomColors":{"type":"boolean","description":"Whether to allow custom color or not."}}},{"example":"single","description":"Renders a date picker.","properties":{"type":{"const":"date"},"default":{"type":"string","description":"Default value that should be applied when first adding the block."},"fallback":{"type":"string","description":"Fallback value that that will display when field value is empty."},"startOfWeek":{"type":"number","description":"The day that the week should start on. 0 for Sunday, 1 for Monday, etc."}}},{"example":"single","description":"Renders a date and time picker.","properties":{"type":{"const":"datetime"},"default":{"type":"string","description":"Default value that should be applied when first adding the block."},"fallback":{"type":"string","description":"Fallback value that that will display when field value is empty."},"is12Hour":{"type":"boolean","description":"Whether we use a 12-hour clock. With a 12-hour clock, an AM/PM widget is displayed and the time format is assumed to be MM-DD-YYYY (as opposed to the default format DD-MM-YYYY)."}}},{"example":"files","description":"Renders a button to the media library. Picked items can be reordered inline.","properties":{"type":{"const":"files"},"default":{"type":["array","object","number"],"description":"Default value that should be applied when first adding the block."},"fallback":{"type":["array","object","number"],"description":"Fallback value that that will display when field value is empty."},"addToGallery":{"type":"boolean","description":"If true, the gallery media modal opens directly in the media library where the user can add additional images. If false the gallery media modal opens in the edit mode where the user can edit existing images, by reordering them, remove them, or change their attributes. Only applies if gallery === true."},"allowedTypes":{"type":["array","string"],"description":"Array with the types of the media to upload/select from the media library. Each type is a string that can contain the general mime type e.g: 'image', 'audio', 'text', or the complete mime type e.g: 'audio/mpeg', 'image/gif'. If allowedTypes is unset all mime types should be allowed."},"gallery":{"type":"boolean","description":"If true, the component will initiate all the states required to represent a gallery. By default, the media modal opens in the gallery edit frame, but that can be changed using the addToGalleryflag."},"max":{"type":"number","description":"Maximum amount of files that can be added."},"min":{"type":"number","description":"Minimum amount of files that can be added."},"multiple":{"type":"boolean","description":"Whether to allow multiple selections or not."},"size":{"type":"boolean","description":"Adds a media size dropdown to the field."},"textMediaButton":{"type":"string","description":"Media button text."},"title":{"type":"string","description":"Title displayed in the media modal."},"returnFormat":{"type":"string","description":"Specifies the return format value.","enum":["object","id","url"],"default":"object"},"returnSize":{"type":"string","description":"The media size to return when using the URL return format."}}},{"example":"option","description":"Renders a gradient palette and gradient picker","properties":{"type":{"const":"gradient"},"options":{"type":"array","default":{"type":"array","description":"Default value that should be applied when first adding the block."},"fallback":{"type":"array","description":"Fallback value that that will display when field value is empty."},"items":{"type":"object","properties":{"name":{"type":"string"},"value":{"type":"string"},"slug":{"type":"string"}},"description":"Options to choose from."}},"populate":{"type":"object","properties":{"function":{"type":"string","description":"The function that should be executed."},"type":{"type":"string","enum":["function","custom"]},"custom":{"type":"string","description":"Custom data ID."},"position":{"type":"string","description":"How the data should be positioned in regards to the default options.","enum":["before","after"],"default":"after"}}},"clearable":{"type":"boolean","description":"Whether the palette should have a clearing button or not."},"disableCustomGradients":{"type":"boolean","description":"Whether to allow custom color or not."}}},{"example":"icon","description":"Renders an SVG icon from an icon set.","properties":{"default":{"type":"object","description":"Default value that should be applied when first adding the block."},"fallback":{"type":"object","description":"Fallback value that that will display when field value is empty."},"type":{"const":"icon"},"sets":{"type":["array","string"],"description":"Which icon set to include. Leave empty to include all."},"subSets":{"type":["array","string"],"description":"Which sub icon set to include. Leave empty to include all."},"returnFormat":{"type":"string","description":"The format to return the icon in.","enum":["object","element"]}}},{"example":"link","description":"Renders a link control to choose internal or external links.","properties":{"type":{"const":"link"},"default":{"type":"object","description":"Default value that should be applied when first adding the block."},"fallback":{"type":"object","description":"Fallback value that that will display when field value is empty."},"hasRichPreviews":{"type":"boolean","description":"Whether rich previews should be shown when adding an URL."},"noDirectEntry":{"type":"boolean","description":"Whether to allow turning a URL-like search query directly into a link."},"noURLSuggestion":{"type":"boolean","description":"Whether to add a fallback suggestion which treats the search query as a URL."},"opensInNewTab":{"type":"boolean","description":"Adds a toggle control to the link modal."},"showSuggestions":{"type":"boolean","description":"Whether to present suggestions when typing the URL."},"textButton":{"type":"string","description":"Custom text that should be displayed inside the link button."},"withCreateSuggestion":{"type":"boolean","description":"Whether to allow creation of link value from suggestion."}}},{"description":"Renders a message with custom content.","properties":{"type":{"const":"message"},"default":{"type":"string","description":"Default value that should be applied when first adding the block."},"fallback":{"type":"string","description":"Fallback value that that will display when field value is empty."},"value":{"type":"string","description":"The message to display. Block and attribute data is available in bracket syntax, e.g.: `{block.title}` or `{attributes.text}`"}}},{"example":"single","description":"Renders a number input.","properties":{"type":{"const":"number"},"default":{"type":"number","description":"Default value that should be applied when first adding the block."},"fallback":{"type":"number","description":"Fallback value that that will display when field value is empty."},"dragDirection":{"type":"string","description":"Determines the drag axis to increment/decrement the value.","enum":["n","e","s","w"]},"dragThreshold":{"type":"number","description":"If isDragEnabled is true, this controls the amount of px to have been dragged before the value changes."},"hideHTMLArrows":{"type":"boolean","description":"If true, the default input HTML arrows will be hidden."},"isShiftStepEnabled":{"type":"boolean","description":"If true, enables mouse drag gesture to increment/decrement the number value. Holding SHIFT while dragging will increase the value by the shiftStep."},"max":{"type":"number","description":"The maximum value length."},"min":{"type":"number","description":"Minimum value length."},"required":{"type":"boolean","description":"If true enforces a valid number within the controls min/max range. If false allows an empty string as a valid value."},"shiftStep":{"type":"number","description":"Amount to increment by when the SHIFT key is held down. This shift value is a multiplier to the step value. For example, if the step value is 5, and shiftStep is 10, each jump would increment/decrement by 50."},"step":{"type":"number","description":"Amount by which the value is changed when incrementing/decrementing. It is also a factor in validation as value must be a multiple of step (offset by min, if specified) to be valid. Accepts the special string value any that voids the validation constraint and causes stepping actions to increment/decrement by 1."}}},{"example":"option","description":"Renders a set of radio inputs.","properties":{"type":{"const":"radio"},"default":{"type":["string","number"],"description":"Default value that should be applied when first adding the block."},"fallback":{"type":["string","number"],"description":"Fallback value that that will display when field value is empty."},"options":{"type":"array","items":{"type":"object","properties":{"label":{"type":"string"},"value":{"type":["string","number"]},"innerBlocks":{"type":"array","items":{"$ref":"#/definitions/Block"}}},"required":["value"]},"description":"Options to choose from."},"returnFormat":{"type":"string","description":"Specifies the return format value.","enum":["value","label","both"],"default":"value"},"populate":{"type":"object","properties":{"function":{"type":"string","description":"The function that should be executed."},"type":{"type":"string","enum":["query","function","custom","fetch"]},"query":{"type":"string","enum":["posts","users","terms"],"description":"Type of query that should be used to fetch data."},"arguments":{"type":["object","array"],"description":"Query or fetch arguments.","properties":{"urlSearch":{"type":"string","description":"Search URL when using the \"fetch\" type."}}},"custom":{"type":"string","description":"Custom data ID."},"position":{"type":"string","description":"How the data should be positioned in regards to the default options.","enum":["before","after"],"default":"after"},"returnFormat":{"type":"object","description":"Format of the returning data when using objects.","properties":{"value":{"type":"string"},"label":{"type":"string"}}}}}}},{"example":"single","description":"Renders a range input to set a numerical value between two points.","properties":{"type":{"const":"range"},"default":{"type":"number","description":"Default value that should be applied when first adding the block."},"fallback":{"type":"number","description":"Fallback value that that will display when field value is empty."},"allowReset":{"type":"boolean","description":"If this property is true, a button to reset the slider is rendered."},"initialPosition":{"type":"number","description":"The slider starting position, used when no value is passed. The initialPosition will be clamped between the provided min and max prop values."},"isShiftStepEnabled":{"type":"boolean","description":"If true, enables mouse drag gesture to increment/decrement the number value. Holding SHIFT while dragging will increase the value by the shiftStep."},"marks":{"type":"array","items":{"type":"object","properties":{"label":{"type":"string"},"value":{"type":"number"}}},"description":"Renders a visual representation of step ticks. Custom mark indicators can be provided by an Array."},"max":{"type":"number","description":"The maximum value length."},"min":{"type":"number","description":"Minimum value length."},"railColor":{"type":"string","description":"CSS color string to customize the rail elements background."},"resetFallbackValue":{"type":"number","description":"The value to revert to if the Reset button is clicked (enabled by allowReset)"},"separatorType":{"type":"string","description":"Define if separator line under/above control row should be disabled or full width. By default it is placed below excluding underline the control icon.","enum":["none","fullWidth","topFullWidth"]},"shiftStep":{"type":"number","description":"Amount to increment by when the SHIFT key is held down. This shift value is a multiplier to the step value. For example, if the step value is 5, and shiftStep is 10, each jump would increment/decrement by 50."},"showTooltip":{"type":"boolean","description":"Forcing the Tooltip UI to show or hide. This is overridden to false when step is set to the special string value any."},"step":{"type":"number","description":"Amount by which the value is changed when incrementing/decrementing. It is also a factor in validation as value must be a multiple of step (offset by min, if specified) to be valid. Accepts the special string value any that voids the validation constraint and causes stepping actions to increment/decrement by 1."},"trackColor":{"type":"string","description":"CSS color string to customize the track elements background."},"withInputField":{"type":"boolean","description":"Determines if the input number field will render next to the RangeControl. This is overridden to false when step is set to the special string value any."}}},{"example":["option","option-multiple"],"description":"Renders a select input with support for single or multiple selections.","properties":{"type":{"const":"select"},"default":{"type":["array","string","number"],"description":"Default value that should be applied when first adding the block."},"fallback":{"type":["array","string","number"],"description":"Fallback value that that will display when field value is empty."},"multiple":{"type":"boolean","description":"If true, multiple options can be selected. \"stylisedUi\" will be automatically enabled."},"options":{"type":"array","items":{"type":"object","properties":{"label":{"type":"string"},"value":{"type":["string","number"]},"innerBlocks":{"type":"array","items":{"$ref":"#/definitions/Block"}}},"required":["value"]},"description":"Options to choose from."},"returnFormat":{"type":"string","description":"Specifies the return format value.","enum":["value","label","both"],"default":"value"},"populate":{"type":"object","properties":{"fetch":{"type":"boolean","description":"If true, search value will be used to search through data. Only works with \"query\" type."},"function":{"type":"string","description":"The function that should be executed."},"type":{"type":"string","enum":["query","function","custom","fetch"]},"query":{"type":"string","enum":["posts","users","terms"],"description":"Type of query that should be used to fetch data."},"arguments":{"type":["object","array"],"description":"Query or fetch arguments.","properties":{"urlSearch":{"type":"string","description":"Search URL when using the \"fetch\" type."}}},"custom":{"type":"string","description":"Custom data ID."},"position":{"type":"string","description":"How the data should be positioned in regards to the default options.","enum":["before","after"],"default":"after"},"returnFormat":{"type":"object","description":"Format of the returning data when using objects.","properties":{"value":{"type":"string"},"label":{"type":"string"}}}}},"stylisedUi":{"type":"boolean","description":"Renders a stylised version of a select with the ability to search through items."},"allowNull":{"type":["boolean","string"],"description":"Allows the user to select an empty choice. If true, the label will be empty, otherwise the option will render the specified string."},"allowReset":{"type":"boolean","description":"If this property is true, a button to reset the select is rendered."}}},{"description":"Renders a tabbed interface for grouping fields.","properties":{"type":{"const":"tabs"},"tabs":{"type":"array","description":"The tabs to display.","items":{"type":"object","required":["title"],"properties":{"title":{"type":"string","description":"The title of the tab."},"attributes":{"type":"array","description":"Custom attributes that will be applied to the block.","items":{"$ref":"#/definitions/Attribute"}},"conditions":{"type":"array","description":"Conditional logic detailing when the field should be displayed in the editor.","items":{"type":"array","items":{"type":"object","required":["operator"],"properties":{"id":{"type":"string","description":"ID of the field whose value will be used for the conditionally render it."},"operator":{"type":"string","description":"How the values should be compared.","enum":["==","!=","includes","!includes","empty","!empty","<",">","<=",">="]},"type":{"type":"string","description":"Condition type."},"value":{"type":["string","number","boolean"],"description":"Value that will be compared."}}}}},"blockEditor":{"type":"object","description":"Block specific options for rendering inside the Block Editor.","properties":{"disableLoading":{"type":"boolean","description":"Whether the block should should load inside the Block Editor or show a placeholder."}}},"editor":{"type":"object","description":"Block specific options for the editor.","properties":{"assets":{"type":"array","description":"List of WordPress script or style handles that should be added to the preview.","items":{"type":"string"}}}},"interactivity":{"oneOf":[{"type":"boolean"},{"type":"object","properties":{"enqueue":{"type":"boolean","description":"Enqueue the Interactivity API."}}}],"description":"Enable the WordPress Interactivity API for this block."},"icon":{"type":"string","description":"Custom SVG icon to be displayed inside the editor."},"innerBlocks":{"type":"string","description":"HTML content that will be rendered as the inner blocks."},"override":{"type":"boolean","description":"Whether this block should overwrite another block."},"refreshOn":{"type":"array","description":"When the block should refresh. This is useful when the block relies on external data like custom fields.","items":{"type":"string"}},"transforms":{"type":"object","description":"Custom block transforms.","properties":{"from":{"type":"array","items":{"type":"object","properties":{"type":{"type":"string","enum":["block","enter","prefix"]},"blocks":{"type":"array","items":{"type":"string"}},"regExp":{"type":"string"},"prefix":{"type":"string"}},"required":["type"],"additionalProperties":false}}},"required":["from"],"additionalProperties":false}}}}}},{"example":"single","description":"Renders a single line text input.","properties":{"type":{"const":"text"},"default":{"type":"string","description":"Default value that should be applied when first adding the block."},"fallback":{"type":"string","description":"Fallback value that that will display when field value is empty."},"max":{"type":"number","description":"The maximum value length."},"min":{"type":"number","description":"Minimum value length."}}},{"example":"single","description":"Renders a textarea input.","properties":{"type":{"const":"textarea"},"default":{"type":"string","description":"Default value that should be applied when first adding the block."},"fallback":{"type":"string","description":"Fallback value that that will display when field value is empty."},"max":{"type":"number","description":"The maximum value length."},"min":{"type":"number","description":"Minimum value length."},"rows":{"type":"number","description":"The number of rows the textarea should contain."}}},{"example":"toggle","description":"Renders a true/false toggle.","properties":{"type":{"const":"toggle"},"default":{"type":"boolean","description":"Default value that should be applied when first adding the block."},"fallback":{"type":"boolean","description":"Fallback value that that will display when field value is empty."}}},{"example":"single","description":"Attribute field for RichText fields.","properties":{"type":{"const":"richtext"},"default":{"type":"string","description":"Default value that should be applied when first adding the block."},"fallback":{"type":"string","description":"Fallback value that that will display when field value is empty."}}},{"example":"single","description":"Renders a number input with a unit dropdown.","properties":{"type":{"const":"unit"},"default":{"type":"string","description":"Default value that should be applied when first adding the block."},"fallback":{"type":"string","description":"Fallback value that that will display when field value is empty."},"disableUnits":{"type":"boolean","description":"If true, the unit select field is hidden."},"isPressEnterToChange":{"type":"boolean","description":"If true, the ENTER key press is required in order to trigger an onChange. If enabled, a change is also triggered when tabbing away."},"isResetValueOnUnitChange":{"type":"boolean","description":"If true, and the selected unit provides a default value, this value is set when changing units."},"isUnitSelectTabbable":{"type":"boolean","description":"Determines if the unit select field is tabbable."},"units":{"type":"array","default":{"type":"array","description":"Default value that should be applied when first adding the block."},"fallback":{"type":"array","description":"Fallback value that that will display when field value is empty."},"items":{"type":"object","properties":{"default":{"type":"number"},"label":{"type":"string"},"value":{"type":"string"}}}}}},{"example":"single","description":"Renders a WYSIWYG editor.","properties":{"type":{"const":"wysiwyg"},"default":{"type":"string","description":"Default value that should be applied when first adding the block."},"fallback":{"type":"string","description":"Fallback value that that will display when field value is empty."},"toolbar":{"type":"object","description":"The toolbar configuration for the editor.","properties":{"tags":{"type":"object","description":"Which HTML tags are allowed.","properties":{"headings":{"type":"array","description":"Which HTML headings levels are allowed."}}},"formats":{"type":"object","description":"Which text formats are allowed.","properties":{"bold":{"type":"boolean","description":"Whether bold text format is allowed."},"italic":{"type":"boolean","description":"Whether italic text format is allowed."},"orderedList":{"type":"boolean","description":"Whether ordered list text format is allowed."},"strikethrough":{"type":"boolean","description":"Whether strikethrough text format is allowed."},"underline":{"type":"boolean","description":"Whether underline text format is allowed."},"unorderedList":{"type":"boolean","description":"Whether unordered list text format is allowed."},"textAlign":{"type":"object","description":"Which text alignment formats are allowed.","properties":{"alignments":{"type":"array","description":"Which text alignments are allowed.","items":{"type":"string","enum":["left","center","right","justify"]}}}}}}}}}},{"properties":{"type":{"pattern":"^custom/.+$","description":"References a reusable custom field definition."}},"required":["type"]}]},"Block":{"type":"object","properties":{"name":{"type":"string"},"innerBlocks":{"type":"array","items":{"$ref":"#/definitions/Block"}},"attributes":{"type":"object","additionalProperties":true}},"required":["name"]}},"blockstudio":{"type":["object","boolean"],"description":"Blockstudio specific settings.","properties":{"attributes":{"type":"array","description":"Custom attributes that will be applied to the block.","items":{"_note":"All field types from definitions.Attribute apply here, plus these additional types:","additionalTypes":[{"description":"Renders multiple fields in an (optionally) collapsible container.","properties":{"type":{"const":"group"},"title":{"type":"string","description":"Title text. It shows even when the component is closed."},"opened":{"type":"boolean","description":"When set to true, the component will remain open regardless of the initialOpen prop and the"},"initialOpen":{"type":"boolean","description":"Whether or not the panel will start open."},"scrollAfterOpen":{"type":"boolean","description":"Scrolls the content into view when visible."},"class":{"type":"string","description":"Custom CSS class that will be applied to the group."},"style":{"type":"object","description":"Custom CSS styles that will be applied to the group."},"attributes":{"type":"array","description":"Same field types as the top-level attributes."}}},{"description":"Renders a set of fields that can be repeated.","properties":{"type":{"const":"repeater"},"min":{"type":"number","description":"Minimum amount of rows."},"max":{"type":"number","description":"Maximum amount of rows."},"textButton":{"type":"string","description":"Text for the add button."},"textMinimized":{"type":["string","object"],"description":"Text that will be displayed when rows are minimized.","properties":{"id":{"type":"string","description":"ID of the attribute which should be used as the text."},"fallback":{"type":"string","description":"Fallback text if the attribute is not set."},"prefix":{"type":"string","description":"Prefix for the text."},"suffix":{"type":"string","description":"Suffix for the text."}}},"textRemove":{"type":["string","boolean"],"description":"Text to display in alert when removing repeater row."},"attributes":{"type":"array","description":"Same field types as the top-level attributes."}}}]}},"conditions":{"type":"array","description":"Conditional logic detailing when the field should be displayed in the editor.","items":{"type":"array","items":{"type":"object","required":["operator"],"properties":{"id":{"type":"string","description":"ID of the field whose value will be used for the conditionally render it."},"operator":{"type":"string","description":"How the values should be compared.","enum":["==","!=","includes","!includes","empty","!empty","<",">","<=",">="]},"type":{"type":"string","description":"Condition type."},"value":{"type":["string","number","boolean"],"description":"Value that will be compared."}}}}},"blockEditor":{"type":"object","description":"Block specific options for rendering inside the Block Editor.","properties":{"disableLoading":{"type":"boolean","description":"Whether the block should should load inside the Block Editor or show a placeholder."}}},"editor":{"type":"object","description":"Block specific options for the editor.","properties":{"assets":{"type":"array","description":"List of WordPress script or style handles that should be added to the preview.","items":{"type":"string"}}}},"interactivity":{"oneOf":[{"type":"boolean"},{"type":"object","properties":{"enqueue":{"type":"boolean","description":"Enqueue the Interactivity API."}}}],"description":"Enable the WordPress Interactivity API for this block."},"icon":{"type":"string","description":"Custom SVG icon to be displayed inside the editor."},"innerBlocks":{"type":"string","description":"HTML content that will be rendered as the inner blocks."},"override":{"type":"boolean","description":"Whether this block should overwrite another block."},"refreshOn":{"type":"array","description":"When the block should refresh. This is useful when the block relies on external data like custom fields.","items":{"type":"string"}},"transforms":{"type":"object","description":"Custom block transforms.","properties":{"from":{"type":"array","items":{"type":"object","properties":{"type":{"type":"string","enum":["block","enter","prefix"]},"blocks":{"type":"array","items":{"type":"string"}},"regExp":{"type":"string"},"prefix":{"type":"string"}},"required":["type"],"additionalProperties":false}}},"required":["from"],"additionalProperties":false}},"additionalProperties":false}}
```

### Settings Schema (blockstudio.json)

```json
{"title":"JSON schema for Blockstudio settings","$schema":"http://json-schema.org/draft-04/schema#","type":"object","properties":{"users":{"type":"object","description":"Settings related to allowed users with access to the settings and editor.","properties":{"ids":{"id":"userIds","type":"array","default":[],"items":{"type":"integer"},"description":"List of user IDs with access to the settings and editor.","descriptionFilter":"This filter allows you to enable the editor for specific user IDs.","help":"Comma separated list of user IDs. Example: 1,2,3","example":[1]},"roles":{"id":"userRoles","type":"array","default":[],"items":{"type":"string"},"description":"List of user roles with access to the settings and editor.","descriptionFilter":"This filter allows you to enable the editor for specific user roles.","help":"Comma separated list of user roles. Example: administrator,editor","example":["administrator","editor"]}}},"assets":{"type":"object","description":"Settings related to asset management.","properties":{"enqueue":{"type":"boolean","default":true,"description":"Enqueue assets in frontend and editor.","descriptionFilter":"This filter allows you to enable/disable the enqueueing of assets in frontend and editor.","example":false},"reset":{"type":"object","default":{"enabled":false,"fullWidth":[]},"description":"Control removal of WordPress core block styles.","properties":{"enabled":{"type":"boolean","default":false,"description":"Remove all WordPress core block styles on the frontend and in the editor.","descriptionFilter":"This filter allows you to enable/disable the removal of WordPress core block styles.","example":true},"fullWidth":{"type":"array","default":[],"items":{"type":"string"},"description":"Post types where the editor uses full-width layout by removing classic editor constraints.","descriptionFilter":"This filter allows you to control which post types use full-width editing.","example":["page"]}}},"minify":{"type":"object","description":"Settings related to asset minification.","properties":{"css":{"type":"boolean","default":false,"description":"Minify CSS.","descriptionFilter":"This filter allows you to enable/disable the minification of CSS.","example":true},"js":{"type":"boolean","default":false,"description":"Minify JS.","descriptionFilter":"This filter allows you to enable/disable the minification of JS.","example":true}}},"process":{"type":"object","description":"Settings related to asset processing.","properties":{"scss":{"type":"boolean","default":false,"description":"Process SCSS in .css files.","descriptionFilter":"This filter allows you to enable/disable the processing of SCSS in .css files.","example":true},"scssFiles":{"type":"boolean","default":true,"description":"Process .scss files to CSS.","descriptionFilter":"This filter allows you to enable/disable the processing of .scss files to CSS.","example":true}}}},"additionalProperties":true},"tailwind":{"type":"object","description":"Settings related to Tailwind.","properties":{"enabled":{"type":"boolean","default":false,"description":"Enable Tailwind.","descriptionFilter":"This filter allows you to enable/disable Tailwind.","example":true},"config":{"type":"string","default":"","description":"Tailwind CSS configuration using v4 CSS-first syntax.","descriptionFilter":"This filter allows you to add a custom Tailwind CSS configuration.","element":"textarea","example":"@theme { --color-primary: pink; }"}},"additionalProperties":true},"editor":{"type":"object","description":"Settings related to the editor.","properties":{"formatOnSave":{"type":"boolean","default":false,"description":"Format code upon saving.","descriptionFilter":"This filter allows you to enable/disable the formatting of code upon saving.","example":true},"assets":{"id":"editorAssets","type":"array","default":[],"description":"Additional asset IDs to be enqueued.","descriptionFilter":"This filter allows you to enqueue additional assets in the editor.","example":["my-stylesheet","another-stylesheet"]},"markup":{"type":["string","boolean"],"element":"textarea","default":"","description":"Additional markup to be added to the end of the editor.","descriptionFilter":"This filter allows you to add additional markup to the end of the editor.","example":"<style>body { background: black; }</style>"}},"additionalProperties":true},"blockEditor":{"type":"object","description":"Settings related to Gutenberg.","properties":{"disableLoading":{"type":"boolean","default":false,"description":"Disable loading of blocks inside the Block Editor.","descriptionFilter":"This filter allows you to disable the loading of blocks inside the Block Editor.","example":true},"cssClasses":{"id":"blockEditorCssClasses","type":"array","default":[],"description":"Stylesheets whose CSS classes should be available for choice in the class field.","descriptionFilter":"This filter allows you to add stylesheets whose classes should be available for choice in the class field.","example":["my-stylesheet","another-stylesheet"]},"cssVariables":{"id":"blockEditorCssVariables","type":"array","default":[],"description":"Stylesheets whose CSS variables should be available for autocompletion in the code field.","descriptionFilter":"This filter allows you to add stylesheets whose CSS variables should be available for autocompletion in the code field.","example":["my-stylesheet","another-stylesheet"]}},"additionalProperties":true},"library":{"type":"boolean","default":false,"description":"Add block library.","descriptionFilter":"This filter allows you to enable the block library.","example":true},"ai":{"id":"aiLlmMd","type":"object","description":"Settings related to AI-powered context generation.","properties":{"enableContextGeneration":{"type":"boolean","default":false,"description":"Enables the automatic creation of a comprehensive context file for use with large language model (LLM) tools (e.g., Cursor). This file compiles current installation data: all available block definitions and paths, Blockstudio-specific settings, relevant block schemas, and combined Blockstudio documentation, providing a ready-to-use resource for prompt engineering and AI code development.","descriptionFilter":"This filter allows you to enable or disable context file generation for LLM tool integration. When enabled, the context file assembles up-to-date block data, Blockstudio settings of the current install, all relevant schemas, and Blockstudio documentation into a single source for use with AI development tools.","example":true}},"additionalProperties":true},"dev":{"type":"object","description":"Settings related to developer tools.","properties":{"grab":{"type":"object","description":"Settings related to the element grabber.","properties":{"enabled":{"type":"boolean","default":false,"description":"Enable the element grabber.","descriptionFilter":"This filter allows you to enable/disable the element grabber.","example":false}}},"canvas":{"type":"object","description":"Settings related to the canvas.","properties":{"enabled":{"type":"boolean","default":false,"description":"Enable the canvas.","descriptionFilter":"This filter allows you to enable/disable the canvas.","example":false},"adminBar":{"type":"boolean","default":true,"description":"Show the WordPress admin bar when viewing the canvas.","descriptionFilter":"This filter allows you to show/hide the WordPress admin bar on the canvas.","example":true}}}},"additionalProperties":true}},"additionalProperties":true}
```

### Page Schema (page.json)

```json
{"title":"JSON schema for Blockstudio page definitions","$schema":"http://json-schema.org/draft-04/schema#","type":"object","required":["name"],"properties":{"name":{"type":"string","description":"Unique identifier for the page. Used internally to track and reference the page definition.","example":"about"},"title":{"type":"string","description":"The title of the WordPress page/post. Defaults to a human-readable version of the name if not specified.","example":"About Us"},"slug":{"type":"string","description":"The URL slug for the page. Defaults to the name if not specified.","example":"about-us"},"postType":{"type":"string","default":"page","description":"The WordPress post type to create. Can be any registered post type.","example":"page"},"postStatus":{"type":"string","default":"draft","description":"The initial status for newly created posts. Does not affect existing posts.","enum":["publish","draft","pending","private"],"example":"publish"},"postId":{"type":"integer","description":"Pin the page to a specific WordPress post ID. Uses import_id during creation to request this ID. If the ID is already taken by an unrelated post, WordPress silently auto-assigns a new ID.","example":42},"blockEditingMode":{"type":"string","enum":["default","contentOnly","disabled"],"description":"Controls how blocks can be edited. 'default' allows full editing, 'contentOnly' only allows text editing, 'disabled' prevents all editing.","example":"disabled"},"templateLock":{"type":["string","boolean"],"default":"all","description":"Controls how users can modify the block structure. 'all' prevents all modifications, 'insert' prevents adding/removing blocks, false allows full editing.","enum":["all","insert","contentOnly",false],"example":"all"},"templateFor":{"type":["string","null"],"default":null,"description":"When specified, this page's block structure becomes the default template for the specified post type. Any new posts of that type will start with this template.","example":"product"},"sync":{"type":"boolean","default":true,"description":"Whether to automatically sync the page content when the template file changes. Set to false to create the page once and prevent future automatic updates.","example":true}},"additionalProperties":true}
```

### Extension Schema (extensions.json)

```json
{"_note":"Extension schema is identical to the block schema above, plus this additional \"extend\" property on blockstudio.","extend":{"type":"object","description":"The extend block definition.","properties":{"priority":{"type":"number","description":"In what spot the extension should be rendered in the sidebar."}}}}
```
